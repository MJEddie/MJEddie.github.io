{"pages":[],"posts":[{"title":"[實作] AJAX - GitHub Finder","text":"成品GitHub Finder 介紹串接 GitHub REST API 搜尋 GitHub 使用者的練習，會顯示使用者的相關資訊 ( 專案數、追蹤人數等 )，以及最近的專案，搜尋不到使用者時有告警顯示提醒。 切版方面使用 Bootstrap，頁面在搜尋前只有 Nav bar、search bar 跟 footer 區塊， search bar 在 hover 時才會完整顯示出來，還未 hover 時只顯示 icon。 功能 顯示使用者資訊 顯示專案 (Repo) 資訊 告警顯示 顯示使用者資訊從 API 獲取使用者資訊 練習用 ajax 來串接 API，確認我們的網址、方法與檔案格式，成功後整理我們要的資料，這邊把為 null 的值改成空白顯示，用 substr 擷取時間字串的前十個字元，讓其格式為 YYYY-MM-DD ，最後呼叫函式顯示在頁面上。 123456789101112131415161718192021222324function getUserData() { $.ajax({ url: `https://api.github.com/users/${userName}`, method: 'GET', dataType: 'json', success: function(res) { let obj = {}; obj.avatar_url = res.avatar_url !== null ? res.avatar_url : ''; obj.name = res.name !== null ? res.name : ''; obj.account = res.login; obj.html_url = res.html_url !== null ? res.html_url : ''; obj.public_repos = res.public_repos !== null ? res.public_repos : ''; obj.public_gists = res.public_gists !== null ? res.public_gists : ''; obj.followers = res.followers !== null ? res.followers : ''; obj.following = res.following !== null ? res.following : ''; obj.company = res.company !== null ? res.company : ''; obj.blog = res.blog !== null ? res.blog : ''; obj.location = res.location !== null ? res.location : ''; obj.created_at = res.created_at.substr(0, 10) !== null ? res.created_at.substr(0, 10) : ''; obj.updated_at = res.updated_at.substr(0, 10) !== null ? res.updated_at.substr(0, 10) : ''; showProfile(obj); } });} 顯示函式 把從 API 拿到的資料放進整理好的各欄位中，最後顯示在頁面上。 123456789101112131415161718192021222324252627282930313233function showProfile(user) { $('#profile').html(` &lt;div class=&quot;card card-body border-0&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-md-3&quot;&gt; &lt;img class=&quot;img-fluid rounded-circle mb-2&quot; src=&quot;${user.avatar_url}&quot;&gt; &lt;h5 class=&quot;mt-2 text-center&quot;&gt;${user.name}&lt;/h5&gt; &lt;h6 class=&quot;mt-2 text-center text-secondary&quot;&gt;${user.account}&lt;/h6&gt; &lt;a href=&quot;${user.html_url}&quot; target=&quot;_blank&quot; class=&quot;btn btn-primary btn-block mb-4&quot;&gt;View Profile&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;col-md-9&quot;&gt; &lt;div class=&quot;container mt-2 px-0&quot;&gt; &lt;span class=&quot;badge badge-primary ml-5&quot;&gt;Public Repos: ${user.public_repos}&lt;/span&gt; &lt;span class=&quot;badge badge-secondary&quot;&gt;Public Gists: ${user.public_gists}&lt;/span&gt; &lt;span class=&quot;badge badge-success&quot;&gt;Followers: ${user.followers}&lt;/span&gt; &lt;span class=&quot;badge badge-info&quot;&gt;Following: ${user.following}&lt;/span&gt; &lt;/div&gt; &lt;ul class=&quot;list-group list-group-flush mt-2 ml-5&quot;&gt; &lt;li class=&quot;list-group-item&quot;&gt;Company: ${user.company}&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;Website/Blog: ${user.blog}&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;Location: ${user.location}&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;Member Since: ${user.created_at}&lt;/li&gt; &lt;li class=&quot;list-group-item&quot;&gt;Currently Updated: ${user.updated_at}&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-md-12&quot;&gt; &lt;h3 class=&quot;page-heading mb-3&quot;&gt;Latest Repos&lt;/h3&gt; &lt;div id=&quot;repos&quot;&gt;&lt;/div&gt; &lt;/div&gt; `);} 顯示專案 (Repo) 資訊對搜尋按鈕綁定滑鼠點擊的事件，把輸入欄位中的使用者名稱傳入 API 中搜尋。 123456searchBtn.click(function() { userName = searchUser.val(); getUserData(userName); getRepoData(userName); searchUser.val('');}) 從 API 獲取專案資訊 和使用者資訊一樣的方式，確認我們的網址、方法與檔案格式， per_page=5 我們設定最多顯示 5 筆專案資料，之後呼叫函式顯示在頁面上。 1234567891011function getRepoData() { $.ajax({ url: `https://api.github.com/users/${userName}/repos?per_page=5&amp;sort=created: asc`, method: 'GET', dataType: 'json', success: function(res) { data = res; showRepos(data); } });} 顯示函式 每筆專案資料我們用一個 &lt;div&gt; 包起來，把專案相關資訊放在裡面呈現，如果專案敘述為 null 則顯示空白，最後把每一筆資料顯示在葉面上。 123456789101112131415161718192021function showRepos(repos) { repos.forEach(function(repo) { const repoData = $('&lt;div class=&quot;card card-body mb-2 border-0&quot;&gt;&lt;/div&gt;').appendTo('#repos'); let repoDes = repo.description !== null ? repo.description : ''; repoData.html(` &lt;div class=&quot;row shadow-sm p-3 bg-white rounded&quot;&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;a href=&quot;${repo.html_url}&quot; target=&quot;_blank&quot;&gt; &lt;h3&gt;${repo.name}&lt;/h3&gt; &lt;/a&gt; &lt;p&gt;${repoDes}&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;col-md-6&quot;&gt; &lt;span class=&quot;badge badge-warning m-1&quot;&gt;Stars ${repo.stargazers_count}&lt;/span&gt; &lt;span class=&quot;badge badge-success m-1&quot;&gt;Watchers ${repo.watchers_count}&lt;/span&gt; &lt;span class=&quot;badge badge-info m-1&quot;&gt;Forks ${repo.forks_count}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; `); });} 告警顯示當搜尋不到使用者名稱時，會跳出告警提示使用者，我們在獲取使用者資訊的 API 中增加失敗處理函式。 123456error: function(res) { data = res.responseJSON.message; if (data === 'Not Found') { showAlert(data, 'alert alert-danger'); } } 把我們要顯示的訊息整理好準備在頁面上顯示，利用 Bootstrap 提供的 Alerts 方法可以設定我們的告警樣式，我們增加名稱為 alert alert-danger 的 class 讓其顯示為紅色，text-center 則讓告警的訊息置中，insertBefore() 決定我們要在頁面的哪個 DOM 之中插入顯示我們的告警訊息，顯示告警時清空之前搜尋的使用者資訊。 最後我們設置一個定時器，讓告警訊息只顯示 2 秒後便移除。 1234567891011function showAlert(message, className) { const alertMessage = $('&lt;div&gt;&lt;/div&gt;').attr('class', className + ' text-center'); alertMessage.text(`User &quot;${userName}&quot; is ${message}`); alertMessage.insertBefore($('.search.card.card-body.border-0')); $('#profile').html(''); // clear display after 2 sec setTimeout(() =&gt; { alertMessage.remove(); }, 2000);}","link":"/2021/02/01/AJAX-GitHub-Finder/"},{"title":"[實作] AJAX - Twitch Live Streams","text":"成品Twitch Live Streams 介紹串接 Twitch API 獲取直播中的頻道，頻道依照觀眾人數自動排列，上方有頻道分類可以選擇，點擊後出現該分類中直播的頻道，同時變成紫底白字告訴使用者現在顯示的分類，點擊直播畫面開啟新分頁跳轉至該直播頻道，搭配 infinite scroll 頁面下滑到快底時會自動載入新的頻道。 功能 顯示直播中的頻道 Infinite Scroll 頻道分類功能 顯示直播中的頻道申請 client ID 在開始使用 API 前我們需要到主控台申請一組 client ID 作為識別，名稱中不能含有 “twitch”，重新導向網址依照建議填選 “http://localhost&quot; ，分類則依照需求填寫。 Request 申請好 client ID 就可以開始使用 API 了，官方文件中提供多種的使用方式，而我們要使用到的是 Streams 中的 Get Live Streams，這邊我們使用到的參數為： game： 回傳的遊戲類型 limit： 每筆回傳的資料數量 offset： 分頁中回傳的資料數量 我們預設要回傳的遊戲類型是 League of Lengends，每次顯示 9 個頻道，offset 一開始為 0。 123456789101112131415161718192021222324let nowIndex = 0;let gameName = 'League%20of%20Legends';const clientId = 'bgo21lskupamuirpz6ra5cn1ri0mta';function getLiveStreams() { const limit = 9; $.ajax({ url: `https://api.twitch.tv/kraken/streams/?game=${gameName}&amp;limit=${limit}&amp;offset=${nowIndex}`, headers: { 'Client-ID': clientId, 'Accept': 'application/vnd.twitchtv.v5+json' }, method: 'GET', dataType: 'json', success: function(res) { $.each(res.streams, function(i, stream) { showChannel(stream); }); }, error: function(err) { alert(err); } });} Response 為 1234567891011121314151617181920212223242526272829303132333435363738394041{ &quot;streams&quot;: [ { &quot;_id&quot;: 23937446096, &quot;average_fps&quot;: 60, &quot;channel&quot;: { &quot;_id&quot;: 121059319, &quot;broadcaster_language&quot;: &quot;en&quot;, &quot;created_at&quot;: &quot;2016-04-06T04:12:40Z&quot;, &quot;display_name&quot;: &quot;MOONMOON_OW&quot;, &quot;followers&quot;: 251220, &quot;game&quot;: &quot;Overwatch&quot;, &quot;language&quot;: &quot;en&quot;, &quot;logo&quot;: &quot;https://static-cdn.jtvnw.net/jtv_user_pictures/moonmoon_ow-profile_image-0fe586039bb28259-300x300.png&quot;, &quot;mature&quot;: true, &quot;name&quot;: &quot;moonmoon_ow&quot;, &quot;partner&quot;: true, &quot;profile_banner&quot;: &quot;https://static-cdn.jtvnw.net/jtv_user_pictures/moonmoon_ow-profile_banner-13fbfa1ba07bcd8a-480.png&quot;, &quot;profile_banner_background_color&quot;: null, &quot;status&quot;: &quot;KKona where my Darryl subs at KKona&quot;, &quot;updated_at&quot;: &quot;2016-12-15T20:04:53Z&quot;, &quot;url&quot;: &quot;https://www.twitch.tv/moonmoon_ow&quot;, &quot;video_banner&quot;: &quot;https://static-cdn.jtvnw.net/jtv_user_pictures/moonmoon_ow-channel_offline_image-2b3302e20384eee8-1920x1080.png&quot;, &quot;views&quot;: 9869754 }, &quot;created_at&quot;: &quot;2016-12-15T14:55:49Z&quot;, &quot;delay&quot;: 0, &quot;game&quot;: &quot;Overwatch&quot;, &quot;is_playlist&quot;: false, &quot;preview&quot;: { &quot;large&quot;: &quot;https://static-cdn.jtvnw.net/previews-ttv/live_user_moonmoon_ow-640x360.jpg&quot;, &quot;medium&quot;: &quot;https://static-cdn.jtvnw.net/previews-ttv/live_user_moonmoon_ow-320x180.jpg&quot;, &quot;small&quot;: &quot;https://static-cdn.jtvnw.net/previews-ttv/live_user_moonmoon_ow-80x45.jpg&quot;, &quot;template&quot;: &quot;https://static-cdn.jtvnw.net/previews-ttv/live_user_moonmoon_ow-{width}x{height}.jpg&quot; }, &quot;video_height&quot;: 720, &quot;viewers&quot;: 11523 }, ... ]} 可以看到 streams中為我們需要的資料，接著呼叫函式來處理我們的資料 顯示直播頻道 呼叫函式，將回傳的資料整理然後顯示在頁面上。另外我們在 HTML 中寫入 onclick=&quot;window.open('${url}','_blank')&quot; 就可以達到點擊時開啟新分頁跳轉至該直播頻道。 另外用一個函式來處理觀看人數，超過萬人觀看時改變顯示，例如 11000 觀看會變成 1.1 萬。 12345678910111213141516171819202122232425262728293031323334353637function showChannel(stream) { // 抓取資料 const preImg = stream.preview.medium; const avatarImg = stream.channel.logo; const title = stream.channel.status; const name = stream.channel.display_name; const url = stream.channel.url; const viewers = stream.viewers; // 插入 DOM 中 const channel = $('&lt;div class=&quot;channel&quot;&gt;&lt;div&gt;'); channel.html(` &lt;div class=&quot;wrap&quot; onclick=&quot;window.open('${url}','_blank')&quot;&gt; &lt;div class=&quot;preview&quot;&gt; &lt;img src=${preImg} alt=&quot;preview&quot;&gt; &lt;/div&gt; &lt;div class=&quot;viewer&quot;&gt;觀眾人數 : ${formatViewer(viewers)}&lt;/div&gt; &lt;div class=&quot;info&quot;&gt; &lt;div class=&quot;avatar&quot;&gt; &lt;img src=${avatarImg} alt=&quot;streamer&quot;&gt; &lt;/div&gt; &lt;div class=&quot;intro&quot;&gt; &lt;h4 class=&quot;channel-name&quot;&gt;${title} ...&lt;/h4&gt; &lt;span class=&quot;streamer&quot;&gt;${name}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; `); $('#channels').append(channel);}// format viewerfunction formatViewer(viewer) { return viewer &gt;= 10000 ? (viewer / 10000).toFixed(1) + '萬' : viewer;} Infinite Scroll加入之前學習到的 infinite scroll 功能，透過 isLoading 來限制每次快滑到底時只發出一次請求。 123456789$(window).scroll(function() { const { scrollTop, scrollHeight, clientHeight } = document.documentElement; if (scrollTop + clientHeight &gt;= scrollHeight - 200) { if (!isLoading) { getLiveStreams(); } }}); 一開始 isLoading 為 false 獲取 API 資料時為 true 資料渲染至頁面後 nowIndex += 9，代表我們這次渲染的頻道數量，之後自動載入頻道時會從第 10 筆資料開始載入，並將 isLoading 設為 false 防止一直發出請求 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function getLiveStreams() { const limit = 9; isLoading = true; $.ajax({ url: `https://api.twitch.tv/kraken/streams/?game=${gameName}&amp;limit=${limit}&amp;offset=${nowIndex}`, headers: { 'Client-ID': clientId, 'Accept': 'application/vnd.twitchtv.v5+json' }, method: 'GET', dataType: 'json', success: function(res) { $.each(res.streams, function(i, stream) { showChannel(stream); }); }, error: function(err) { alert(err); } });}function showChannel(stream) { // 抓取資料 const preImg = stream.preview.medium; const avatarImg = stream.channel.logo; const title = stream.channel.status; const name = stream.channel.display_name; const url = stream.channel.url; const viewers = stream.viewers; // 插入 DOM 中 const channel = $('&lt;div class=&quot;channel&quot;&gt;&lt;div&gt;'); channel.html(` &lt;div class=&quot;wrap&quot; onclick=&quot;window.open('${url}','_blank')&quot;&gt; &lt;div class=&quot;preview&quot;&gt; &lt;img src=${preImg} alt=&quot;preview&quot;&gt; &lt;/div&gt; &lt;div class=&quot;viewer&quot;&gt;觀眾人數 : ${viewers}&lt;/div&gt; &lt;div class=&quot;info&quot;&gt; &lt;div class=&quot;avatar&quot;&gt; &lt;img src=${avatarImg} alt=&quot;streamer&quot;&gt; &lt;/div&gt; &lt;div class=&quot;intro&quot;&gt; &lt;h4 class=&quot;channel-name&quot;&gt;${title} ...&lt;/h4&gt; &lt;span class=&quot;streamer&quot;&gt;${name}&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; `); $('#channels').append(channel); nowIndex += 9; isLoading = false;} 頻道分類功能監聽按鈕的點擊事件，取得按鈕代表的頻道分類，發出請求並渲染至頁面上，加上 active 的 class 名稱改變 CSS 樣式告知使用者現在顯示的直播分類。 要注意的是要將 offset 歸零再將資料渲染至頁面上，不然的話會因為已經渲染過的關係(offset 的值)，會從當下 offset 的值之後開始渲染。 HTML 123456&lt;div class=&quot;category&quot;&gt; &lt;button name=&quot;Just%20Chatting&quot;&gt;Just Chatting&lt;/button&gt; &lt;button name=&quot;Hearthstone&quot;&gt;Hearthstone&lt;/button&gt; &lt;button name=&quot;Apex%20Legends&quot;&gt;Apex Legends&lt;/button&gt; &lt;button name=&quot;League%20of%20Legends&quot; class=&quot;active&quot;&gt;League of Legends&lt;/button&gt;&lt;/div&gt; JavaScript 12345678$('button').click(function() { gameName = $(this).attr('name'); $(this).addClass('active').siblings().removeClass('active'); $('#channels').html(''); // reset nowIndex = 0; getLiveStreams();","link":"/2021/02/25/AJAX-Twitch-Live-Streams/"},{"title":"[實作] AJAX - Youtube Search Engine","text":"成品Youtube Search Engine 介紹串接 Youtube Data API 將搜尋結果列出來，並引入 fancybox 點擊播放時彈出視窗顯示在頁面最上層，如下圖。 功能 列出搜尋結果 上一頁 / 下一頁 功能 Fancybox 列出搜尋結果申請 Youtube Data API 在開始使用 API 前我們需要申請一組金鑰 key 作為授權碼，先到 Developer Console’s 啟用 API 和服務。 找到並點選「Youtube Data APIv3」 啟用 API 啟用後進入到 Youtube Data API v3 的管理頁面建立憑證，把產生的金鑰 key 記下來 Request 申請好憑證就可以開始使用 API 了，官方文件 Search list 中說明了可使用的參數，這邊說明幾個待會會使用到的參數： part：每個搜尋結果中所包含的資訊，頻道名稱、影片敘述、縮圖等，根據手冊將值設為 snippet maxResults：設定每次回傳的數量，範圍 0~50，預設值為 5 order：將搜尋結果排序的方法，分別是 date：根據創建日期排序 rating：根據評價排序 relevance：根據與搜尋的關鍵字相關性排序 title：根據標題字母順序排序 videoCount：根據頻道上傳的影片數量排序 viewCount：根據觀看數排序 q：要搜尋的關鍵字 pageToken：辨認要回傳的結果頁面，nextPageToken、prevPageToken 可以用來回傳下一頁 / 上一頁的搜尋結果 對搜尋按鈕監聽獲取搜尋的關鍵字，再來將我們需要的參數設定和申請好的金鑰 key 加入 url 中並發出請求。 成功之後將回傳的pageToken 傳給函式 generateButtons 用來產生 下一頁 / 上一頁的按鈕。 12345678910111213141516171819202122232425262728293031let q;$('#search-btn').click(function(e) { e.preventDefault(); // 清空內容 $('#results').html(''); $('#buttons').html(''); q = $('#search-field').val(); getVideos(q);});function getVideos(q) { $.ajax({ url: `https://youtube.googleapis.com/youtube/v3/search?part=snippet&amp;maxResults=5&amp;order=relevance&amp;q=${q}&amp;key=API_KEY`, method: 'GET', dataType: 'json', success: function(res) { const nextPageToken = res.nextPageToken; const prevPageToken = res.prevPageToken; $.each(res.items, function(i, item) { showViedos(item); }); generateButtons(prevPageToken, nextPageToken); } });} Response 為 1234567891011121314{ &quot;kind&quot;: &quot;youtube#searchListResponse&quot;, &quot;etag&quot;: etag, &quot;nextPageToken&quot;: string, &quot;prevPageToken&quot;: string, &quot;regionCode&quot;: string, &quot;pageInfo&quot;: { &quot;totalResults&quot;: integer, &quot;resultsPerPage&quot;: integer }, &quot;items&quot;: [ search Resource ]} 其中的 items 中為我們所需要的資訊 12345678910111213141516171819202122232425{ &quot;kind&quot;: &quot;youtube#searchResult&quot;, &quot;etag&quot;: etag, &quot;id&quot;: { &quot;kind&quot;: string, &quot;videoId&quot;: string, &quot;channelId&quot;: string, &quot;playlistId&quot;: string }, &quot;snippet&quot;: { &quot;publishedAt&quot;: datetime, &quot;channelId&quot;: string, &quot;title&quot;: string, &quot;description&quot;: string, &quot;thumbnails&quot;: { (key): { &quot;url&quot;: string, &quot;width&quot;: unsigned integer, &quot;height&quot;: unsigned integer } }, &quot;channelTitle&quot;: string, &quot;liveBroadcastContent&quot;: string }} 顯示搜尋結果 呼叫函式，將回傳的每一筆搜尋結果整理然後顯示在頁面上。 12345678910111213141516171819202122232425function showViedos(item) { // 抓取資料 const videoID = item.id.videoId; const title = item.snippet.title; const description = item.snippet.description; const thumbnail = item.snippet.thumbnails.high.url; const channelTitle = item.snippet.channelTitle; const videoDate = item.snippet.publishedAt; // 插入 DOM 中 const result = $('&lt;li&gt;&lt;/li&gt;'); result.html(` &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;${thumbnail}&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;info&quot;&gt; &lt;h3&gt;&lt;a data-fancybox href=&quot;http://www.youtube.com/embed/${videoID}&quot;&gt;${title}&lt;/a&gt;&lt;/h3&gt; &lt;small&gt;By &lt;span class=&quot;cTitle&quot;&gt;${channelTitle}&lt;/span&gt; on ${videoDate.substr(0,10)}&lt;/small&gt; &lt;p&gt;${description}&lt;/p&gt; &lt;/div&gt; `); $('#results').append(result);} 上一頁 / 下一頁 功能將得到的 pageToken 產生相對應的按鈕，並把值賦予屬性儲存起來，點擊按鈕時執行對應的函式。 第一頁的搜尋結果回傳的只有 nextPageToken，而沒有 prevPageToken 123456789101112131415161718function generateButtons(prevPageToken, nextPageToken) { if (!prevPageToken) { const button = $(` &lt;div class=&quot;button-container&quot;&gt; &lt;button id=&quot;next-button&quot; class=&quot;next-button&quot; data-token=&quot;${nextPageToken}&quot; onclick=&quot;nextPage()&quot;&gt;&lt;/button&gt; &lt;/div&gt; `); $('#buttons').append(button); } else { const button = $(` &lt;div class=&quot;button-container&quot;&gt; &lt;button id=&quot;prev-button&quot; class=&quot;prev-button&quot; data-token=&quot;${prevPageToken}&quot; onclick=&quot;prevPage()&quot;&gt;&lt;/button&gt; &lt;button id=&quot;next-button&quot; class=&quot;next-button&quot; data-token=&quot;${nextPageToken}&quot; onclick=&quot;nextPage()&quot;&gt;&lt;/button&gt; &lt;/div&gt; `); $('#buttons').append(button); }} 從按鈕中的屬性獲取 pageToken 的值，把 pageToken 的值加入 url 中再次發出請求，重新渲染至頁面，這邊用 next page 說明，prev page 也是相同的概念。 123456789101112131415161718192021222324function nextPage() { const token = $('#next-button').data('token'); // 清空內容 $('#results').html(''); $('#buttons').html(''); $.ajax({ url: `https://youtube.googleapis.com/youtube/v3/search?part=snippet&amp;maxResults=5&amp;order=relevance&amp;q=${q}&amp;pageToken=${token}&amp;key=API_KEY`, method: 'GET', dataType: 'json', success: function(res) { const nextPageToken = res.nextPageToken; const prevPageToken = res.prevPageToken; $.each(res.items, function(i, item) { showViedos(item); }); generateButtons(prevPageToken, nextPageToken); } });} Fancybox每一筆搜尋結果使用 fancybox 播放影片，參考文件中 fancybox Iframe 在連結中加入 data-fancybox、data-type=&quot;iframe&quot; 的屬性。 HTML 123456&lt;!-- 引入 fancybox --&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css&quot; /&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js&quot;&gt;&lt;/script&gt; &lt;!-- 加入 fancybox 屬性 --&gt;&lt;h3&gt;&lt;a data-fancybox data-type=&quot;iframe&quot; href=&quot;http://www.youtube.com/embed/${videoID}&quot;&gt;${title}&lt;/a&gt;&lt;/h3&gt; JavaScript 1234567$('[data-fancybox]').fancybox({ toolbar : false, smallBtn : true, iframe : { preload : false // 自動調整 &lt;iframe&gt; 的寬度/高度 }}) 參考資料 Youtube Data API fancybox","link":"/2021/02/07/AJAX-Youtube-Search-Engine/"},{"title":"[實作] AJAX - Weather Forecast","text":"成品Weather Forecast 介紹串接 中央氣象局 API 獲取台灣未來一週的天氣預報，並依照不同的天氣情況顯示代表的圖示。 左上角顯示今日天氣情況和氣溫，下面則是接下來一週的天氣預報，右邊選單可以選擇其他縣市。 功能 下拉式選單 顯示今日天氣 顯示一週天氣預報 天氣情況圖示 星期顯示 下拉式選單從 API 獲取天氣資訊 中央氣象局 API 提供許多不同地區以及天數的預測資料給我們使用，根據需求我們選擇鄉鎮天氣預報-臺灣未來1週天氣預報。 成功取得資料後整理並先把台灣各地區的城市資料抓出來，並放到下拉式選單中。 12345678910111213function getWeather() { $.ajax({ url: 'https://opendata.cwb.gov.tw/api/v1/rest/datastore/F-D0047-091?Authorization=CWB-373C6328-6BF2-41B3-BB3B-147802B82875&amp;format=JSON&amp;locationName=&amp;elementName=&amp;sort=time', method: 'GET', dataType: 'json', success: function(res) { data = res.records.locations[0]; city = data.location; selectCity(city); } });} 用 for 迴圈將台灣各地區城市依照資料排序一筆一筆的放到下拉式選單中，這樣我們的選單即完成了。 之後對選單綁定事件監聽，將選取到的城市索引值和資料丟到函式中即可顯示該城市的天氣預報。 12345678910111213141516function selectCity(data) { let select = document.querySelector('#select'); for (let i = 0; i &lt; data.length; i++) { city = data[i].locationName; let value = i; select.innerHTML += ` &lt;option value=&quot;${value}&quot;&gt;${city}&lt;/option&gt; `; }}$('#select').change(function() { cityIndex = $('#select :selected').val(); showWeather(data, cityIndex); showWeek(data, cityIndex);}); 顯示今日天氣整理得到的資料從中擷取我們要的部分，分別是 WeatherDescription : 天氣情況描述 MinT : 最低溫度 MaxT : 最高溫度 之後用 Date() 取得現在時間並將其轉為字串整理後，和剛剛整理好的氣象資訊一起顯示在頁面上。 12345678910111213141516171819202122function getDate() { let timeNow = new Date(); return timeNow;}function showWeather(data, cityIndex) { $('.today-description').html(''); cityName = data.location[cityIndex].locationName; const weather = data.location[cityIndex].weatherElement; const description = weather[6].time[0].elementValue[0].value; const minT = `${weather[8].time[0].elementValue[0].value} °C`; const maxT = `${weather[12].time[0].elementValue[0].value} °C`; let descriptionImg = checkWeather(description); let date = getDate().toGMTString(); $('.today-description').html(` &lt;h1&gt;${cityName}&lt;/h1&gt; &lt;h2&gt;${date.substr(0,16)}&lt;/h2&gt; ${descriptionImg} &lt;div class=&quot;today-description&quot;&gt;${description} &lt;br&gt;${minT} / ${maxT}&lt;/div&gt; `)} 顯示一週天氣預報這邊要處理的基本上和顯示今日天氣一樣，只不過我們額外用 &lt;div&gt; 把每一天的資訊包起來，然後依序增加在頁面上。 12345678910111213141516171819202122function showWeek(data, cityIndex) { $('#week').html(''); const weather = data.location[cityIndex].weatherElement; for (i = 1; i &lt; 7; i++) { let timeIndex = 2 * i; const day = $('&lt;div&gt;&lt;/div&gt;').attr('class', `day-${i}`); const description = weather[6].time[timeIndex].elementValue[0].value; const minT = `${weather[8].time[timeIndex].elementValue[0].value} °C`; const maxT = `${weather[12].time[timeIndex].elementValue[0].value} °C`; let descriptionImg = checkWeather(description); day.html(` &lt;h3&gt;${calendar[i].week}&lt;/h3&gt; &lt;div class=&quot;description&quot;&gt; ${descriptionImg} &lt;/div&gt; &lt;div class=&quot;temp&quot;&gt;${minT} / ${maxT}&lt;/div&gt; &lt;div class=&quot;week-description&quot;&gt;${description}&lt;/div&gt; `); $('#week').append(day); }} 天氣情況圖示天氣情況的描述眾多，將其簡短地分成四大類，依據天氣情況則回傳對應的圖示。 晴時多雲 : 多雲時晴、多雲 : 多雲時陰、陰時多雲、陰天 : 其他有下雨的情況 : 1234567891011function checkWeather(description) { if (description === '晴時多雲') { return '&lt;img src=&quot;images/svg/sunny.svg&quot; alt=&quot;weather-img&quot;&gt;'; } else if (description === '多雲時晴' || description === '多雲') { return '&lt;img src=&quot;images/svg/sun-cloudy.svg&quot; alt=&quot;weather-img&quot;&gt;'; } else if (description === '多雲時陰' || description === '陰時多雲' || description === '陰天') { return '&lt;img src=&quot;images/svg/cloudy.svg&quot; alt=&quot;weather-img&quot;&gt;'; } else { return '&lt;img src=&quot;images/svg/rainy.svg&quot; alt=&quot;weather-img&quot;&gt;'; }} 星期顯示這邊我們要獲得從今天往後的星期，使用的原理是這樣 : 先取得今天的時間 取得明天的時間 獲得明天時間的日期、星期 儲存在陣列中使用 一樣的邏輯就可以取得接下來一週的日期跟星期，我們另外存在陣列中方便使用。 123456789101112131415161718const calendar = [];const weekDay = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']; for (i = 1; i &lt; 7; i++) { calendar[i] = {} // 取得今天的時間 let loopDate = new Date(); // 取得明天的時間 let loopDay = loopDate.getDate() + i; let loopValue = loopDate.setDate(loopDay) // 取的明天時間的日期跟星期 let newDate = new Date(loopValue) // 儲存起來使用 calendar[i].day = newDate.getDate() calendar[i].week = weekDay[newDate.getDay()] } 參考資料預報因子欄位中文說明表","link":"/2021/02/03/AJAX-Weather-Forecast/"},{"title":"[筆記] Command Line 常用指令","text":"Command Line 是什麼？Command-Line Interface（命令列介面，簡稱CLI）是在圖形使用者介面得到普及之前使用最為廣泛的使用者介面，它通常不支援滑鼠，用戶通過鍵盤輸入指令，電腦接收到指令後，予以執行。也有人稱之為文字使用者介面（character user interface, CUI） Command Line 基本指令 pwd：print working directory，印出現在資料夾位置 ls：list contents，列出資料夾內所有檔案 ls -l：列出詳細資訊 ls -a：可以看到隱藏的檔案 ls -al:列出詳細資訊，包含隱藏檔案 ls -R：可以看到所有的子目錄，較少用 可以看到 ls -l 中列出的資訊中包含擁有者、權限以及上次修改時間 cd：change directory，切換資料夾 cd ..：上層資料夾 cd ../..：上上層資料夾 指令練習 mkdir：make directory，建立資料夾 指令練習，可以看到新增了一個 “practice” 資料夾 touch：新增檔案，如果輸入的檔案存在則會修改檔案時間 指令練習，進入剛新增的資料夾，新增一個 “index.html” 的檔案 cp：copy，複製檔案 指令練習，複製 “index.html” 為 “about.html” mv：move，移動檔案，或是重新命名檔案名稱 指令練習，移動 “about.html” 到上一層 “Music” 資料夾中 cd 可使用相對路徑或是絕對路徑，要將檔案移動到上一層時必須使用絕對路徑 將剛移動過來的 “about.html” 重新命名為 “index.html” rm：remove，刪除檔案 rmdir，刪除資料夾 rm -rf，強制刪除檔案，小心使用 指令練習，將剛新增的 “practice” 資料夾刪除 cat：查看檔案內容 可以看到 “about.html” 裡的內容為 “Hello” 原本 about.html 裡是沒有東西，先用 vim 指令編輯 about.html更多 vim 的操作可以參考 簡明 Vim 文字編輯器操作入門教學 參考資料Linux Command","link":"/2020/11/20/Command-Line%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"},{"title":"[筆記] Git &amp; Github 入門","text":"Git 是什麼？一種分散式版本控制系統 (Distributed Version Control Systems)，可藉由它產生一個數據庫 (repository)，並且做到分散式版本控制。由於可在多處放置同一份程式碼、歷史紀錄追蹤與回朔，讓協同開發變得容易。 Git 和 GitHub 的差異git 是一套軟體系統，而 GitHub 則是運用 git 提供程式原始碼版本控制與代管服務的服務平台。 Git 安裝Git 軟體安裝 Git 版本控制基本觀念 Git 常用指令 初始化數據庫： git init 查詢當前狀態：git status 將檔案加入到索引：git add . 將索引檔案變成一個更新(commit)：git commit -m &quot;修改內容&quot; 觀察 commit 歷史紀錄： git log 下載遠端數據庫： git clone 數據庫網址 更新遠端數據庫： git push origin master GitHub 專案建立申請完 Github 帳號後點選右上角來新增 new repository 這邊輸入專案的名稱 專案建立之後如果是全新開始，請依「create a new repository on the command line」的指示進行；如果是要上傳現存專案，則依照「push an existing repository from the command line」指示進行。 GitHub page 實作進入到專案資料夾，git status 確認資料夾內的狀態，可以看到 index.html 跟 css 資料夾裡的 main.css 檔案還未加入索引 這邊我用舊有專案示範，有先修改內容，所以索引內還沒有修改後的 index.html 跟 main.css 把修改後的 index.html 和 main.css 用 git add 指令加入索引中，再次確認 git 狀態，可以看到檔案顏色變成綠色，代表已經加入 接著 git commit -m &quot;2020style&quot; 加入到本地數據庫，並註解 “2020style” 再來用 git branch gh-page 來新增名為 gh-page 的分支，之後用 git branch 來確認是否新增成功，成功的話可以看到我們現在有兩個分支 輸入 git checkout gh-page 切換到 gh-page 分支 輸入 git push將本地的檔案 push 到 GitHub 上，但是 GitHub 還沒有這個分支，所以會提示我們要輸入以下指令來完成 git push --set-upstream origin gh-pages 接下來在 GitHub 頁面上可以看到分支建立成功 剛剛新增的檔案也在分支內 之後就可以透過網址來瀏覽我們的靜態網頁https://mjeddie.github.io/RootsSkate/ 參考資料Git 官方教學文件 Git 與 Github 是什麼？如何使用 Git？ 延伸閱讀5xruby - 為你自己學 Git ihower 的 Git 教室 保哥 - 30 天精通 Git 版本控管 連猴子都能懂得 Git 入門教學","link":"/2020/11/21/Git%E5%85%A5%E9%96%80/"},{"title":"[實作] Hexo Blog 架設","text":"前言第一篇文章來記錄一下 Hexo Blog 的架設過程，也是參考了很多資料才寫出來的。 安裝需求 在安裝 HEXO 前我們要先確認電腦已經安裝好 Node.js 跟 Git ，因為 Hexo 是基於 Node.js 的開發套件，所以要使用前必須要先安裝 NPM(Node Package Manager) ， Git 則是為了能夠在 GitHub 上架設網站的伺服器，還沒安裝的話到官網下載安裝即可。 安裝 HEXO確認 Node.js &amp; Git 安裝好之後，終端機輸入: $ npm install hexo-cli -g (完成後用 hexo v 指令確認是否安裝成功，有出現版本號就完成安裝) $ hexo init blog $ cd blog $ npm install $ hexo server or $ hexo s 設定 HEXO_config.yml網站配置檔案，可以修改大部分的設定，像是標題、敘述、支援語言、主題等。 themes網站主題放置的資料夾，官網有提供許多主題供使用。 第一篇文章輸入指令 $ hexo new &lt;title&gt; 後在source/_posts 中將看到 “ 佈署上 GitHub修改 _config.yml 12deploy: type: git 安裝 hexo-deployer-git 1$ npm install hexo-deployer-git --save 修改 _config.yml 1234deploy: type: git repo: https://github.com/&lt;yourAccount&gt;/&lt;repo&gt; branch: &lt;your branch&gt; 執行 hexo deploy -g 就可以將網站佈署到 GitHub上。接著輸入 &lt;yourAccount&gt;.github.io就能看到自己的網站囉。","link":"/2020/11/16/Hexo-Blog/"},{"title":"[實作] Bootstrap - Form Validator","text":"成品From Validator 介紹對之前實作的 From Validator 用 Bootstrap 的 form 改寫。 功能 檢查必填項目，空白則顯示 xxx is required 檢查字元長度 ( 使用者名稱 315 個字元、密碼 816 個字元) 驗證 email 格式，不符合的話顯示 Email is not valid 確認密碼是否正確 輸入時能立刻判斷是否符合格式 HTML 架構每一個表單控制項要增加 class form-control 並與其搭配的 label 元素用帶有 class form-group 的 div 包起來形成一個表單群組。class invalid-feedback可以設定我們的錯誤訊息。 123456789101112131415161718192021222324&lt;form class=&quot;needs-validation&quot; novalidate oninput='password2.setCustomValidity(password2.value != password.value ? &quot;Passwords do not match.&quot; : &quot;&quot;)'&gt; &lt;h2&gt;Register With Us&lt;/h2&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;username&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;username&quot; placeholder=&quot;Enter username&quot; pattern=&quot;^[a-zA-Z0-9]{3,15}$&quot; required&gt; &lt;small class=&quot;invalid-feedback&quot;&gt;Username is required&lt;/small&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;email&quot;&gt;Email address&lt;/label&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;email&quot; placeholder=&quot;Enter email&quot; pattern='^(([^&lt;&gt;()[\\]\\\\.,;:\\s@&quot;]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@&quot;]+)*)|(&quot;.+&quot;))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$' required&gt; &lt;small class=&quot;invalid-feedback&quot;&gt;Email is not valid&lt;/small&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;password&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; id=&quot;password&quot; placeholder=&quot;Enter password&quot; pattern=&quot;(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$%^&amp;*-]).{8,16}$&quot; required&gt; &lt;small class=&quot;invalid-feedback&quot;&gt;Password is required&lt;/small&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;password2&quot;&gt;Confirm Password&lt;/label&gt; &lt;input type=&quot;password&quot; name=&quot;password2&quot; class=&quot;form-control&quot; id=&quot;password2&quot; placeholder=&quot;Enter password again&quot; data-match=&quot;#password&quot; required&gt; &lt;small class=&quot;invalid-feedback&quot;&gt;Passwords do not match&lt;/small&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt; 驗證方式Bootstrap 的表單驗證是透過偽元素 :invalid :valid 進行的，可以適用在 &lt;input&gt;、&lt;select&gt;和&lt;textarea&gt;。 要使用 Bootstrap 的驗證方式只需要在我們的父元素 &lt;form&gt; 加上 was-validate clss，而對於自定義的表單驗證訊息，需要將 novalidate 屬性添加到 &lt;form&gt; 中。接著使用所提供的程式範本，可以完成按下 submit 時的表單驗證。 12345678910111213141516171819(function () { 'use strict' // Fetch all the forms we want to apply custom Bootstrap validation styles to var forms = document.querySelectorAll('.needs-validation') // Loop over them and prevent submission Array.prototype.slice.call(forms) .forEach(function (form) { form.addEventListener('submit', function (event) { if (!form.checkValidity()) { event.preventDefault() event.stopPropagation() } form.classList.add('was-validated') }, false) })})() 即時驗證 剛有提到 Bootstrap 的表單驗證是透過偽元素 :invalid :valid 進行的，而作為備用 is-invalid is-valid class 可以用來替代偽元素在伺服器端的驗證，我們只需透過對 input 的監聽判斷是否符合我們所設置的規則，添加is-invalid或是is-valid class 即可達到立即判斷的功能。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152form.addEventListener('input', validate);function validate(e) { const target = e.target; switch (target.id) { case 'username': const userRegex = /^[a-zA-Z0-9]{3,15}$/; if (userRegex.test(target.value.trim())) { target.classList.add('is-valid'); target.classList.remove('is-invalid'); } else { target.classList.add('is-invalid'); target.classList.remove('is-valid'); } break; case 'email': if (target.id == &quot;email&quot;) { const emailRegex = /^(([^&lt;&gt;()[\\]\\\\.,;:\\s@&quot;]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@&quot;]+)*)|(&quot;.+&quot;))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/; if (emailRegex.test(target.value.trim())) { target.classList.add('is-valid'); target.classList.remove('is-invalid'); } else { target.classList.add('is-invalid'); target.classList.remove('is-valid'); } } break; case 'password': const pwdRegex = /(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$%^&amp;*-]).{8,16}$/; if (pwdRegex.test(target.value.trim())) { target.classList.add('is-valid'); target.classList.remove('is-invalid'); } else { target.classList.add('is-invalid'); target.classList.remove('is-valid'); } break; case 'password2': const pwd2Regex = /(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$%^&amp;*-]).{8,16}$/; const pwd = document.querySelector('#password'); const pwd2 = document.querySelector('#password2'); if (pwd.value === pwd2.value) { target.classList.add('is-valid'); target.classList.remove('is-invalid'); } else { target.classList.add('is-invalid'); target.classList.remove('is-valid'); } break; }}","link":"/2021/01/03/Bootstrap-Form-Validator/"},{"title":"[筆記] JavaScript - Date() 日期與時間","text":"JavaScript 沒有日期資料型態，但是它有提供 Date() 物件，使用內件的日期物件與方法、可以取得與操作日期時間。Date() 物件是基於世界標準時間（UTC） 1970 年 1 月 1 日開始的毫秒數值來儲存時間。 Date() 的創建Date() 物件有四種可在建構式傳入參數的類型如下 不帶參數 : 表示當前日期和時間1new Date() // Tue Jan 19 2021 20:28:00 GMT+0800 (台北標準時間) 時間單位 : 必要參數 : 年、月 年 (四位數) 月 (從 0~11，分別代表一月到十二月) 選擇性參數 : 日、時、分、秒、毫秒 日 (預設為 1) 時、分、秒、毫秒 (預設為 0) 1new Date(2021,0) // Fri Jan 01 2021 00:00:00 GMT+0800 (台北標準時間) milliseconds : 表示從 1970-01-01 00:00:00 UTC+0 開始所經過的毫秒數123new Date(0) // Thu Jan 01 1970 08:00:00 GMT+0800 (台北標準時間)// 增加一年new Date(365 * 24 * 60 * 60 * 1000) // Fri Jan 01 1971 08:00:00 GMT+0800 (台北標準時間) date string : dataString 為表示時間日期的字串，要符合 ISO8601 或 國際標準 RFC2822 的格式 1new Date('2021/01/01') // Fri Jan 01 2021 00:00:00 GMT+0800 (台北標準時間) Date() 的方法取得時間new Date() 不加任何參數就會使用瀏覽器環境來取得目前的日期時間 1const timeNow = const new Date(); // Tue Jan 19 2021 20:28:00 GMT+0800 (台北標準時間) 取得日期時間的某個值我們用 new Date()取得時間後，可以只取其中的某個值，像是年、月、日等。 12345const timeNow = const new Date(); // Tue Jan 19 2021 20:28:00 GMT+0800 (台北標準時間)timeNow.getFullYear() // 2021timeNow.getMonth() // 0timeNow.getDate() // 19timeNow.getDay() // 2 getFullYear(): 取得西元年，為四位數字 getMonth(): 取得月份的值，範圍 0~11 getDate(): 取得日期的值，範圍 1~31 getDay(): 取得星期的值，範圍 0~6 其中我們會發現 getMonth()、getDay() 回傳的其實是陣列索引值，其中星期是從禮拜日作為一週的第一天。以下是其他取得時間的方法。 方法 敘述 getFullYear() 從 Date 物件返回年份 ( 四位數字 ) getMonth() 從 Date 物件返回月份 (0 ~ 11) getDate() 從 Date 物件返回一個月中的某一天 (1 ~ 31) getHours() 返回 Date 物件的小時 (0 ~ 23) getMinutes() 返回 Date 物件的分鐘 (0 ~ 59) getSeconds() 返回 Date 物件的秒數 (0 ~ 59) getMilliseconds() 返回 Date 物件的毫秒(0 ~ 999) getTime() 返回 1970 年 1 月 1 日至今的毫秒數 getDay() 從 Date 物件返回一週中的某一天 (0 ~ 6) 設置時間從 MDN文件 中我們知道以下幾種設置時間的方式，時間為 1995/12/17 03:24:00，如果沒特別指定的話預設是 0。 12345var today = new Date();var birthday = new Date('December 17, 1995 03:24:00');var birthday = new Date('1995-12-17T03:24:00');var birthday = new Date(1995, 11, 17); // Sun Dec 17 1995 00:00:00 GMT+0800 (台北標準時間)var birthday = new Date(1995, 11, 17, 3, 24, 0); 下面是其他設定的方法，所以方法都可以使用正負整數或是 0，假如超過設定範圍則會自動加減做進位，用剛剛的例子說明，把月份的參數設定為 12 ( 範圍 0~11)，那麼時間會變成 1996/1/17 03:24:00。 1var birthday = new Date(1995, 12, 17, 3, 24, 0); // Wed Jan 17 1996 03:24:00 GMT+0800 (台北標準時間) 這次我們把小時換成 -2 來看看會發生什麼事，會發現時間變成前一天的 22:24:00，別忘了取得時間時回傳的是陣列索引值，所以我們設定 -2 也就是陣列中倒數第二個值，也就是 22 啦。 1var birthday = new Date(1995, 12, 17, -2, 24, 0); // Tue Jan 16 1996 22:24:00 GMT+0800 (台北標準時間) 方法 敘述 setFullYear() 從 Date 物件返回年份 ( 四位數字 ) setMonth() 從 Date 物件返回月份 (0 ~ 11) setDate() 從 Date 物件返回一個月中的某一天 (1 ~ 31) setHours() 返回 Date 物件的小時 (0 ~ 23) setMinutes() 返回 Date 物件的分鐘 (0 ~ 59) setSeconds() 返回 Date 物件的秒數 (0 ~ 59) setMilliseconds() 返回 Date 物件的毫秒(0 ~ 999) setTime() 返回 1970 年 1 月 1 日至今的毫秒數 時間的比較Date() 物件可以用 &gt;, &lt;, &lt;=, &gt;=, &lt;== 或 &gt;== 運算子來比較兩個 Date() 物件，日期越晚的越大 12345678910const today = new Date();const someday = new Date('2022/1/1');if (someday &gt; today) { console.log('Today is before 2022/1/1');} else { console.log('Today is after 2022/1/1');}// Today is before 2022/1/1 但如果要比較兩個日期是否相等，運算子 == != === !==，要先將 Date() 物件用 date.getTime() 轉換為數值型態才能比較 12345const d1 = new Date(2022, 1, 1);const d2 = new Date(2022, 1, 1);const same = d1.getTime() === d2.getTime(); // trueconst notSame = d1.getTime() !== d2.getTime(); // false 參考資料 JavaScript Date Objects MDN Date","link":"/2020/12/26/JavaScript-Date/"},{"title":"[筆記] JavaScript - Event Delegation ( 事件委派 )","text":"Event Delegation ( 事件委派 ) 是一種受惠於 Event Bubbling ( 事件冒泡 ) 而能減少監聽器的方法。 為什麼要用事件委派在 JavaScript 中，添加到頁面上的事件處理程序數量將直接關係到頁面的整體運行性能，如果我們想要取得 ul 中每個 li 的內容，而對每個 li 進行監聽，當數量越來越多時，瀏覽器也就建立了越來越多的監聽器，無形中對效能有很大的傷害，此時我們可以透過事件委派直接監聽父層的 ul，無論內容有多少，瀏覽器都只需要負擔一組事件監聽器的消耗。 範例一使用 jQuery API 語法 1234// jQuery 1.4.3+$( elements ).delegate( selector, events, data, handler );// jQuery 1.7+$( elements ).on( events, selector, data, handler ); selector：選擇器，用來過濾觸發事件的元素。 events：JavsScript 事件類型，如 click、keydown等。 data：規定傳遞到函數的額外數據，可不填寫。 hundle：觸發事件時要執行的功能。 HTML 123456&lt;ul id=&quot;ul&quot;&gt; &lt;li class=&quot;sub-item&quot;&gt;000&lt;/li&gt; &lt;li class=&quot;list-item&quot;&gt;123&lt;/li&gt; &lt;li class=&quot;list-item&quot;&gt;456&lt;/li&gt; &lt;li class=&quot;list-item&quot;&gt;789&lt;/li&gt;&lt;/ul&gt; JavaScript 123456789// Event Delegation$('#ul').click(function(e){ console.log($(e.target).text()); }) // jQuery delegate$('#ul').on('click','li',function(){ console.log($(this).text());}) 範例二只監聽 li 中含有 list-item class 名稱的項目，點擊 sub-item 這個 class 的 li 時就不會有動作。 JavaScript 12345678$('#ul').click(function(e){ console.log($(e.target).text()); }) // jQuery delegate$('#ul').on('click','.list-item',function(){ console.log($(this).text());}) 參考資料 jQuery API Document","link":"/2021/04/17/JavaScript-Event-Delegation/"},{"title":"[筆記] JavaScript - Event Bubbling &amp; Capturing ( 事件冒泡與事件捕獲 )","text":"JavaScript 是一個事件驅動 (Event-driven) 的程式語言，當瀏覽器載入網頁開始讀取後，雖然馬上會讀取 JavaScript 事件相關的程式碼，但是必須等到「事件」被觸發(如使用者點擊、按下鍵盤等)後，才會再進行對應程式的執行。 DOM 的事件流程 (Event Flow)DOM 的事件機制分為三個階段： 捕獲階段 (Capture Phase)：在網頁上點擊一個元素時，這個點擊事件會從 windos 開始往下尋找，一直到點擊的元素 (target)，這個階段稱作捕獲階段。 目標階段 (Target Phase)：在找到目標時，就會是目標階段。當事件傳到 target 本身，沒有分捕獲跟冒泡。 冒泡階段 (Bubbling Phase)：在事件捕獲到後，會一路傳回去 windows，這個時候稱作冒泡階段。 用張大家都很熟悉的 w3c - event-flow 圖來說明這三個階段： 捕獲階段當點擊 td 時，這個點擊事件會從 windows 往下一直找到 td 為止。 目標階段當找到目標 td 時。 冒泡階段當捕獲到目標後，一路傳回去 windows。 也因此會常常聽到所謂的口訣，「先捕獲，再冒泡」。 事件捕獲 (Event capturing)接下來我們用 addEventLinstener 來接聽事件的階段，並且回傳事件階段 (eventPhase) 看一下實際是不是跟我們想像的一樣。 語法 1target.addEventListener(type, listener, useCapture); useCapture： true：監聽捕獲階段。 false：監聽冒泡階段，一般預設為 false。 eventPhase 定義： CAPTURING_PHASE：捕獲階段，回傳值為 1。 AT_TARGET：目標階段，回傳值為2。 BUBBLING_PHASE：冒泡階段，回傳值為3。 範例 HTML 123456789&lt;body&gt; &lt;ul id=&quot;ul&quot;&gt; &lt;li id=&quot;li&quot;&gt; &lt;a id =&quot;a&quot; target=&quot;_blank&quot; href=&quot;http://google.com&quot;&gt; click me &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; JavaScript 123456789101112131415161718const ul = document.getElementById('ul');const li = document.getElementById('li');const a = document.getElementById('a');// ul 的捕獲ul.addEventListener('click', (event) =&gt; { console.log('ul capturing', event.eventPhase);}, true)// li 的捕獲li.addEventListener('click', (event) =&gt; { console.log('li capturing', event.eventPhase);}, true)// a 的捕獲a.addEventListener('click', (event) =&gt; { console.log('a capturing', event.eventPhase);}, true) 結果為： 123&quot;ul capturing&quot; 1&quot;li capturing&quot; 1&quot;a capturing&quot; 2 可以看到點擊 a 時，是由最上層 ul &gt; li &gt; a 一直傳遞到 target a。 事件冒泡 (Event bubbling)一樣用剛才的範例，把監聽的參數改為 false。 1234567891011121314// ul 的冒泡ul.addEventListener('click', (event) =&gt; { console.log('ul bubbling', event.eventPhase);}, false)// li 的冒泡li.addEventListener('click', (event) =&gt; { console.log('li bubbling', event.eventPhase);}, false)// a 的冒泡a.addEventListener('click', (event) =&gt; { console.log('a bubbling', event.eventPhase);}, false) 結果為： 123&quot;a bubbling&quot; 2&quot;li bubbling&quot; 3&quot;ul bubbling&quot; 3 從 targe a &gt; li &gt; ul 一路冒泡回去，其中可以看到 target 的狀態皆為 AT_TARGET，因此我們知道 target 本身，沒有分捕獲跟冒泡。 取消事件傳遞當我們想要阻止事件的冒泡時，可以用 event.stopPropagation() 來停止傳遞。依照 event.stopPropagation() 加在哪一階段，事件傳遞就會終止在該階段，不繼續傳遞下去。 這邊指的「事件傳遞被終止」，是說不會再把事件傳遞給「下一個節點」，但若是在同一個節點上有不只一個 listener，還是會被執行到。 以冒泡的例子來說，加在 a 連結的冒泡階段： 12345678910// a 的冒泡a.addEventListener('click', (event) =&gt; { event.stopPropagation(); console.log('a bubbling', event.eventPhase);}, false)// a 的冒泡 2a.addEventListener('click', (event) =&gt; { console.log('a bubbling 2', event.eventPhase);}, false) 結果就只有： 12&quot;a bubbling&quot; 2&quot;a bubbling 2&quot; 2 想要同一層級的監聽不被執行，可以使用 e.stopImmediatePropagation()。 12345678910// a 的冒泡a.addEventListener('click', (event) =&gt; { event.stopImmediatePropagation(); console.log('a bubbling', event.eventPhase);}, false)// a 的冒泡 2a.addEventListener('click', (event) =&gt; { console.log('a bubbling 2', event.eventPhase);}, false) 結果就只有： 1&quot;a bubbling&quot; 2 取消預設行為event.preventDefault() 為取消瀏覽器的預設行為，像是超連結、表單中的 submit 等，讓其點擊時不會執行預設的動作，因此加上 event.preventDefault() 雖然預設動作會取消，但事件還是會往下傳遞。 123456789101112131415// ul 的冒泡ul.addEventListener('click', (event) =&gt; { console.log('ul bubbling', event.eventPhase);}, false)// li 的冒泡li.addEventListener('click', (event) =&gt; { console.log('li bubbling', event.eventPhase);}, false)// a 的冒泡a.addEventListener('click', (event) =&gt; { event.preventDefault(); console.log('a bubbling', event.eventPhase);}, false) 結果為： 123&quot;a bubbling&quot; 2&quot;li bubbling&quot; 3&quot;ul bubbling&quot; 3 一旦 call 了 event.preventDefault()，在之後傳遞下去的事件裡面也會有效果。 加在 ul 的捕獲事件中，讓其之後一直傳遞，也能讓超連結停止預設動作。 1234ul.addEventListener('click', (event) =&gt; { event.preventDefault(); console.log('ul bubbling', event.eventPhase);}, true) 參考資料 w3c - UI Events 重新認識 JavaScript: Day 14 事件機制的原理 DOM 的事件傳遞機制：捕獲與冒泡","link":"/2021/04/16/JavaScript-Event-bubbling-capturing/"},{"title":"[實作] JavaScript - Exchange Rate Calculate","text":"成品Exchange Rate Calculate 介紹串接 API 並用 jQuery 語法做的匯率轉換器練習。 功能 可選擇貨幣，並顯示匯率 選擇貨幣與金額後，轉換出對應的金額 可以快速交換兩種貨幣 HTML 架構使用 &lt;select&gt; &lt;option&gt; 標籤做出下拉選單的樣式，每個選項中 value 為其代表的貨幣， currency-one 為我們選擇的貨幣，currency-two 則是我們想要兌換的貨幣，中間有 Swap 按鈕可以快速交換兩個貨幣的匯率。 12345678910111213141516171819202122232425262728293031323334&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;currency&quot;&gt; &lt;select id=&quot;currency-one&quot;&gt; &lt;option value=&quot;TWD&quot; selected&gt;台幣 (TWD)&lt;/option&gt; &lt;option value=&quot;USD&quot;&gt;美金 (USD)&lt;/option&gt; &lt;option value=&quot;HKD&quot;&gt;港幣 (HKD)&lt;/option&gt; &lt;option value=&quot;GBP&quot;&gt;英鎊 (GBP)&lt;/option&gt; &lt;option&gt;...&lt;/option&gt; &lt;option&gt;...&lt;/option&gt; &lt;option&gt;...&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;number&quot; id=&quot;amount-one&quot; placeholder=&quot;0&quot; value=&quot;1&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;swap-rate-container&quot;&gt; &lt;button class=&quot;btn&quot; id=&quot;swap&quot;&gt; Swap &lt;/button&gt; &lt;div class=&quot;rate&quot; id=&quot;rate&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;currency&quot;&gt; &lt;select id=&quot;currency-two&quot;&gt; &lt;option value=&quot;TWD&quot;&gt;台幣 (TWD)&lt;/option&gt; &lt;option value=&quot;USD&quot; selected&gt;美金 (USD)&lt;/option&gt; &lt;option value=&quot;HKD&quot;&gt;港幣 (HKD)&lt;/option&gt; &lt;option value=&quot;GBP&quot;&gt;英鎊 (GBP)&lt;/option&gt; &lt;option&gt;...&lt;/option&gt; &lt;option&gt;...&lt;/option&gt; &lt;option&gt;...&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;number&quot; id=&quot;amount-two&quot; placeholder=&quot;0&quot;/&gt; &lt;/div&gt;&lt;/div&gt; 匯率計算使用 fetch() 來取得遠端各個貨幣對應其他貨幣的兌換率，then() 做為下一步，資料取得後可在 then() 裡面接收，因為檔案為 json 格式，所以在取得檔案後透過 json() 處理檔案，接著傳遞到下一層，就可以顯示出匯率以及兌換後的金額。 123456789101112131415function calculate() { const currencyOne = $('#currency-one').val(); const currencyTwo = $('#currency-two').val(); fetch(`https://api.exchangerate-api.com/v4/latest/${currencyOne}`) .then(res =&gt; res.json()) .then(data =&gt; { // console.log(data); const rate = data.rates[currencyTwo]; $('#rate').text(`1 ${currencyOne} = ${rate} ${currencyTwo}`); $('#amount-two').val(($('#amount-one').val() * rate).toFixed(2)); });} 事件監聽當我們改變兌換的金額或是貨幣時，可以做到即時的顯示，對此我們需要監聽選擇的貨幣以及輸入的金額，並在其值改變時再次呼叫函式做匯率的計算，已達到即時顯示的功能。 123456789$('#currency-one').change(function() { calculate();});$('#currency-two').change(function() { calculate();});$('#amount-one').change(function() { calculate();}); 交換貨幣點擊 SWAP 按鈕時把要選擇的貨幣 ( 貨幣 1) 與想要兌換的貨幣( 貨幣 2)做交換，交換完再次呼叫函式計算兌換的金額。 把貨幣 1 的匯率存到變數 temp 貨幣 2 的匯率改為貨幣 1 的匯率 再把原本 temp 中貨幣 1 的匯率存到貨幣 2 再次呼叫函式計算兌換的金額 123456$('#swap').click(function() { const temp = $('#currency-one').val(); $('#currency-one').val($('#currency-two').val()); $('#currency-two').val(temp); calculate();}) 參考資料 Fetch API Fetch Response","link":"/2021/01/06/JavaScript-Exchange-Rate-Calculate/"},{"title":"[筆記] JavaScript - Math() 函數的使用","text":"紀錄內建的 Math() 屬性和方法，可以 console.dir(Math) 查看 Math() 的所有函數方法。 Math() 的屬性 這邊所列的屬性可以直接呼叫它 12Math.LN2 // 0.6931471805599453Math.SQRR2 // 1.4142135623730951 Math() 的方法 這邊舉幾個常用的方法 Math.abs() 取絕對值 1Math.abs(-21) // 21 Math.random() 取 0~1 的隨機小數 123Math.random() // 0.17817644947082445Math.random() // 0.1376729897557134Math.random() // 0.6986859722517493 Math.celi() 取大於這個數的最小整數 12Math.ceil(6.6) // 7Math.ceil(-6.6) // -6 Math.floor() 取小於這個數的最大整數 123Math.floor(3.14) // 3Math.floor(6.6) // 6Math.floor(-6.6) // -7 Math.round() 四捨五入 123Math.round(3.14) // 3Math.floor(6.6) // 7Math.floor(-6.6) // -7 進階應用 取陣列中隨機的值 1Math.floor(Math.random() * arr.length) 參考資料 JavaScript Math 對象","link":"/2020/12/25/JavaScript-Math/"},{"title":"[實作] JavaScript - Form Validator","text":"成品From Validator 介紹JavaScript 可用來在資料被送往伺服器前對 HTML 表單中的這些輸入資料進行驗證，算是很常看到的功能，紀錄一下實作的練習。 功能 檢查必填項目，空白則顯示 xxx is required 檢查字元長度 ( 使用者名稱 315 個字元、密碼 816 個字元) 驗證 email 格式，不符合的話顯示 Email is not valid 確認密碼是否正確 輸入時能立刻判斷是否符合格式 HTML 架構h2 文字搭配表單格式，&lt;label&gt; 元素透過 for 屬性與 &lt;input&gt; 元素的 id 屬性連結，&lt;small&gt; 標籤則用來放置我們要呈現的錯誤訊息。 123456789101112&lt;form id=&quot;form&quot; class=&quot;form&quot;&gt; &lt;h2&gt;Register With Us&lt;/h2&gt; &lt;div class=&quot;form-control&quot;&gt; &lt;label for=&quot;username&quot;&gt;Username&lt;/label&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; placeholder=&quot;Enter username&quot; /&gt; &lt;small&gt;&lt;!-- error message --&gt;&lt;/small&gt; &lt;/div&gt; &lt;div class=&quot; form-control &quot;&gt;Email...&lt;/div&gt; &lt;div class=&quot; form-control &quot;&gt;Password...&lt;/div&gt; &lt;div class=&quot; form-control &quot;&gt;Confirm Password...&lt;/div&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;&lt;/form&gt; 檢查必填項目宣告變數，利用 getElementById() 來取得 HTML 內的元素 12345const form = document.getElementById('form');const username = document.getElementById('username');const email = document.getElementById('email');const password = document.getElementById('password');const password2 = document.getElementById('password2'); 我們希望註冊失敗時則顯示紅色，並且把錯誤訊息顯示出來，成功時則顯示綠色，所以分別建立代表失敗跟成功的顯示函式，用 JavaScript 去切換 class 的名稱，以達到我們想要的功能。 12345678910111213// Show input error messagefunction showError(input, message) { const formControl = input.parentElement; formControl.classList.add('error'); const small = formControl.querySelector('small'); small.innerText = message;}// Show success outlinefunction showSuccess(input) { const formControl = input.parentElement; formControl.classList.add('success');} 檢查必填項目，針對傳入的陣列中每一個元素去檢查，若沒有填寫會顯示 xxx is required。 .trim() 函數用於去除字符串兩端的空白字符 12345678910// Check required fieldsfunction checkRequired(inputArr) { inputArr.forEach(function(input) { if (input.value.trim() === '') { showError(input, `${getFieldName(input)} is required`); } else { showSuccess(input); } });} 其中我們想要讓顯示的第一個英文字母為大寫，所以用另一個函式getFieldName 來處理 取得第一個字母：charAt(0) 轉換成大寫：toUpperCase() 用 slice(1) 得到一個去掉字首的字串並和之前轉換的大寫字母相加 1234// Get fieldnamefunction getFieldName(input) { return input.id.charAt(0).toUpperCase() + input.id.slice(1);} 檢查字元長度用 .length 取得輸入的值去判斷長度，若是不符合我們的設定 (使用者名稱 315 個字元、密碼 816 個字元)呼叫 showError 並顯示錯誤訊息，符合則呼叫 showSucces。 12345678910// Check input lengthfunction checkLength(input, min, max) { if (input.value.length &lt; min &amp;&amp; input.value.trim() !== '') { showError(input, `${getFieldName(input)} must be at least ${min} characters`); } else if (input.value.length &gt; max) { showError(input, `${getFieldName(input)} must be less than ${max} characters`); } else { showSuccess(input); }} 驗證 email 格式把輸入值用 test() 是否與 Email 格式驗證的正規表達式匹配，相符呼叫 showSucces 不符合則呼叫 showError 並顯示錯誤訊息 Email is not valid。 1234567891011/// Check email is validfunction checkEmail(input) { const re = /^(([^&lt;&gt;()[\\]\\\\.,;:\\s@&quot;]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@&quot;]+)*)|(&quot;.+&quot;))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/; if (re.test(input.value.trim())) { showSuccess(input); } else if (input.value.trim() === '') { showError(input, `${getFieldName(input)} is required`); } else { showError(input, 'Email is not valid'); }} 確認密碼是否正確很簡單的對兩個值進行判斷，不相等則呼叫 showError 並顯示錯誤訊息 Passwords do not match。 123456// Check passwords matchfunction checkPasswordMatch(input1, input2) { if (input1.value !== input2.value) { showError(input2, 'Passwords do not match'); }} 輸入時能立刻判斷是否符合格式對我們的 input 做監聽，接著呼叫我們的判斷函式判斷是否符合格式，使用正則表達式來建立我們的規則，使用 test 對我們輸入的字串判斷是否符合正則表達式的規則，然後切換 class 名稱顯示符合或不符合，不符合則會額外顯示錯誤訊息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556form.addEventListener('input', validate);function validate(e) { const target = e.target; switch (target.id) { case 'username': const userRegex = /^[a-zA-Z0-9]{3,15}$/; if (userRegex.test(target.value.trim())) { target.parentElement.classList.add('success'); target.parentElement.classList.remove('error'); } else { target.parentElement.classList.add('error'); target.parentElement.classList.remove('success'); showError(target, 'must be at least 3 characters'); } break; case 'email': if (target.id == &quot;email&quot;) { const emailRegex = /^(([^&lt;&gt;()[\\]\\\\.,;:\\s@&quot;]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@&quot;]+)*)|(&quot;.+&quot;))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/; if (emailRegex.test(target.value.trim())) { target.parentElement.classList.add('success'); target.parentElement.classList.remove('error'); } else { target.parentElement.classList.add('error'); target.parentElement.classList.remove('success'); showError(target, 'Email is not valid'); } } break; case 'password': const pwdRegex = /(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$%^&amp;*-]).{8,16}$/; if (pwdRegex.test(target.value.trim())) { target.parentElement.classList.add('success'); target.parentElement.classList.remove('error'); } else { target.parentElement.classList.add('error'); target.parentElement.classList.remove('success'); showError(target, 'must be at least 8 characters'); } break; case 'password2': const pwd2Regex = /(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$%^&amp;*-]).{8,16}$/; const pwd = document.querySelector('#password'); const pwd2 = document.querySelector('#password2'); if (pwd.value === pwd2.value) { target.parentElement.classList.add('success'); target.parentElement.classList.remove('error'); } else { target.parentElement.classList.add('error'); target.parentElement.classList.remove('success'); showError(target, 'Passwords do not match'); } break; }}","link":"/2020/12/29/JavaScript-Form-Validator/"},{"title":"[筆記] JavaScript - Hoisting ( 提升 )","text":"什麼是 Hoisting？在 JavaScript 中變數和函式的宣告會在編譯階段就被先建立一個記憶體空間，等到實際執行時再將值放入記憶體空間內，也就是說變數的宣告被「提升」到最上面去，不過實際執行的位置並沒有改變。 MDN 中說到： Hoisting 只是用來釐清 JavaScript 在執行階段如何運作的說法，實際位置和程式碼一樣。 變數的 Hoisting接著我們用例子來說明一下： 1console.log(a); // not defined 因為沒有宣告變數 a，所以會出現錯誤 a is not defined。 12console.log(a); // undefinedvar a; 可以看到宣告變數之後，結果會是 undefined，可以發現只要有宣告變數，就不會出錯。 12console.log(a); // undefinedvar a = 1; 接著我們看這個例子為什麼結果不是 1 呢？這段程式碼可以解析成以下： 123var a;console.log(a); // undefineda = 1; 先宣告變數 var a，之後才賦予值 a = 1，只有宣告會提升，賦值不會。 let、const 的 HoistingES6 中導入的新的宣告方式，而 let 跟 const 的 Hoisting 行為比較不一樣，我們看以下範例： 123456var a = 10function test(){ console.log(a) let a}test() 這段範例的結果為 Cannot access 'a' before initialization，這是因為 var 宣告的變數會被初始化為 undefined，而 let 跟 const 並不會被初始化為 undefined，在還未賦值之前是不能被存取的，如果你在賦值之前存取就會拋出錯誤。 函式的 Hoisting 函式陳述式 (Function Statement) 先宣告一個函式再呼叫，我們可以預期它的結果為 &quot;My cat's name is Chloe&quot;。 1234function catName(name) { console.log(&quot;My cat's name is &quot; + name);}catName(&quot;Chloe&quot;); // &quot;My cat's name is Chloe&quot; 如果在宣告之前先呼叫會發生什麼事呢？程式一樣可以運作。 12345catName(&quot;Chloe&quot;); // &quot;My cat's name is Chloe&quot;function catName(name) { console.log(&quot;My cat's name is &quot; + name);} 函式表達式 ( Function Expression ) 接著我們來看看函式表達式的例子： 1234catName(&quot;Chloe&quot;); // catName is not a functionvar catName = function(name) { console.log(&quot;My cat's name is &quot; + name);} 會出現錯誤 catName is not a function，我們來解析一下： 12345var catName;catName(&quot;Chloe&quot;); var catName = function(name) { console.log(&quot;My cat's name is &quot; + name);} 在 catName 還是為 undefined 時，不能當作函式來呼叫，因此會出現錯誤。 Hoisting 的優先權我們把變數跟函式放在一起來看看： 123console.log(a); // ƒ a(){}var a;function a(){}; 雖然變數和函式都會被提升，但是函式的優先權比較高，結果會是 function 而不是 undefined。 如果函式有參數的話怎麼辦？ 12345function test(v){ console.log(v) var v = 3}test(10) 結果是 10 而不是 undefined。 我們來解析一下： 1234567function test(v){ var v = 10 // 因為下面呼叫 test(10) var v console.log(v) v = 3}test(10) 可以發現參數的優先權是大於變數的。 總結 變數和函式的宣告都會提升，優先權為函式 &gt; 參數 &gt; 變數 只有宣告會提升，賦值不會 參考資料 MDN - Hoisting 我知道你懂 hoisting，可是你了解到多深？","link":"/2021/04/14/JavaScript-Hoisting/"},{"title":"[實作] JavaScript - Movie Seat Booking","text":"成品Movie Seat Booking 介紹提供電影和劇院中的座位供選擇以購買門票，並儲存至 localStorage，以便在刷新後資料仍存在。 功能 提供電影以及座位選擇 選擇座位後，自動計算總金額 localStoage 功能 提供電影以及座位選擇HTML 架構 使用 &lt;select&gt; &lt;option&gt; 標籤做出電影選單，每個選項中 value 的值為電影的價格，座位部分用 &lt;ul&gt; &lt;li&gt; 項目標籤說明座位的狀態，用 &lt;div&gt; 去做出每一列的位置 ( 擷取部分程式碼 )。 1234567891011121314151617181920212223242526272829303132333435363738&lt;div class=&quot;movie-container&quot;&gt; &lt;label&gt;Pick a movie:&lt;/label&gt; &lt;select id=&quot;movie&quot;&gt; &lt;option value=&quot;24&quot;&gt;GODZILLA VS KONG ($24)&lt;/option&gt; &lt;option value=&quot;12&quot;&gt;DETECTIVE CONAN THE SCARLET ALIBI ($12)&lt;/option&gt; &lt;option value=&quot;18&quot;&gt;BATMAN BEGINS ($18)&lt;/option&gt; &lt;option value=&quot;9&quot;&gt;SPIDER-MAN ($9)&lt;/option&gt; &lt;/select&gt;&lt;/div&gt;&lt;ul class=&quot;showcase&quot;&gt; &lt;li&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;small&gt;N/A&lt;/small&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;seat selected&quot;&gt;&lt;/div&gt; &lt;small&gt;Selected&lt;/small&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;seat sold&quot;&gt;&lt;/div&gt; &lt;small&gt;Sold&lt;/small&gt; &lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;screen&quot;&gt;&lt;/div&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat sold&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat sold&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;div class=&quot;seat&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS 特效 這邊記錄一下幾個特別的用法： 使用 nth-of-type() 選取器來做出兩旁座位的走道 1234567.seat:nth-of-type(2) { margin-right: 18px; /* 左邊兩排座位的走道 */}.seat:nth-last-of-type(2) { margin-left: 18px; /* 右邊兩排座位的走道 */} 使用 perspective 搭配螢幕的翻轉、陰影打造 3D 透視效果 12345678910111213.container { perspective: 1000px; /*3D效果*/ margin-bottom: 30px;}.screen { background-color: #fff; height: 70px; width: 100%; margin: 15px 0; transform: rotateX(-45deg); /* 翻轉螢幕 */ box-shadow: 0 3px 10px rgba(255, 255, 255, 0.7); /* 陰影效果 */} 選擇座位後，自動計算總金額先對變數進行宣告，其中票價會變動所以用 let 宣告，並將值型別轉換為數字 1234567const container = $('.container');const seats = $('.row .seat:not(.sold)');const count = $('#count');const total = $('#total');const movieSelect = $('#movie');let ticketPrice = parseInt(movieSelect.val()); 這邊用函式來處理選擇的座位數和電影價格，將其渲染至頁面上。透過對電影選單和座位的監聽之後，更新電影的價格以及座位的狀態 (selected)，然後呼叫我們的函式，函式處理的步驟為： 將選擇的座位放入陣列裡：[...selectedSeats] 對陣列中的資料進行處理：map(function(seat) {...}) 得到選擇的位子所代表的索引值：[...seats].indexOf(seat) 123456789101112131415161718192021function updateSelectedCount() { const selectedSeats = $('.row .seat.selected'); const selectedSeatsCount = selectedSeats.length; count.text(selectedSeatsCount); total.text(selectedSeatsCount * ticketPrice);}// Event ListenersmovieSelect.change(function() { ticketPrice = parseInt($(this).val()); updateSelectedCount();});container.click(function(e) { if ($(e.target).hasClass('seat') &amp;&amp; !$(e.target).hasClass('sold')) { $(e.target).toggleClass('selected'); updateSelectedCount(); }}); localStoage 功能參考 MDN locatStorage 後得知用 setItem('key', 'value)' 將資料儲存至對應的 key，之後要讀取的話透過 setItem() 輸入 key 值可以得到對應的 value，我們用一個函式來專門處理資料的儲存。 1234function setMovieData(movieIndex, moviePrice) { localStorage.setItem('selectedMovieIndex', movieIndex); localStorage.setItem('selectedMoviePrice', moviePrice);} 將剛剛選擇的電影和位置儲存至 localStorage，處理的步驟為： 將選擇的座位放入陣列裡：[...selectedSeats] 對陣列中的資料進行處理：map(function(seat) {...}) 得到選擇的位子所代表的索引值：[...seats].indexOf(seat) 其中因為儲存時會被轉成字串格式，如果儲存的資料為物件時，之後讀取資料時會回傳奇怪的字串，我們用 JSON 格式來避免這問題，使用 JSON.stringify() 將資料轉為 JSON 格式的字串。 123456789101112131415161718192021function updateSelectedCount() { const selectedSeats = $('.row .seat.selected'); const seatsIndex = [...selectedSeats].map(function(seat) { return [...seats].indexOf(seat); }); localStorage.setItem('selectedSeats', JSON.stringify(seatsIndex)); const selectedSeatsCount = selectedSeats.length; if (selectedSeatsCount &gt; 1) { $('#seat').text('seats'); } else { $('#seat').text('seat'); } count.text(selectedSeatsCount); total.text(selectedSeatsCount * ticketPrice); setMovieData(movieSelect.get(0).selectedIndex, movieSelect.val());} 讀取 locatStorage 中的資料 使用 JSON.parse 將資料由 JSON 格式字串轉回原本的資料內容及型別，並檢查是否有新點選的位置，渲染至頁面上。 判斷 selectedSeats 有值且不為空值：if (selectedSeats !== null &amp;&amp; selectedSeats.length &gt; 0) 對尚未售出的位置中檢查是否包含其索引值：`seats.each((index, seat) =&gt; { if (selectedSeats.indexOf(index) &gt; -1) }` 將 class 狀態變更為 selected：seat.classList.add('selected'); 1234567891011121314151617function populateUI() { const selectedSeats = JSON.parse(localStorage.getItem('selectedSeats')); if (selectedSeats !== null &amp;&amp; selectedSeats.length &gt; 0) { seats.each((index, seat) =&gt; { if (selectedSeats.indexOf(index) &gt; -1) { seat.classList.add('selected'); } }); } const selectedMovieIndex = localStorage.getItem('selectedMovieIndex'); if (selectedMovieIndex !== null) { movieSelect.get(0).selectedIndex = selectedMovieIndex; }} 參考資料 CSS沒有極限 - CSS transform-3D的透視(perspective) MDN locatStorage JS30-Day15-LocalStorage","link":"/2021/01/05/JavaScript-Movie-Seat-Booking/"},{"title":"[實作] JavaScript - Infinite Scroll Blog","text":"成品Infinite Scroll Blog 介紹利用 JSON Server 產生假文章做無限滾動的練習。 功能 當捲動到頁尾時，會自動讀取( load ) 更多的文章，讀取時有動畫顯示 文章搜尋功能，可以篩選符合的文章內容 獲取文章資料使用 fetch() 來取得遠端的文章資料，這次改用 async/await 來進行改寫，在結構上較易於閱讀。因為檔案為 json 格式，所以在取得檔案後透過 json() 處理檔案。 而我們一開始預設顯示的文章數為一頁五篇文章，以方便我們可以滾動頁面。 123456789101112let limit = 5;let page = 1;async function getPosts() { const res = await fetch( `https://jsonplaceholder.typicode.com/posts?_limit=${limit}&amp;_page=${page}` ); const data = await res.json(); return data;} 設置初始文章我們用一個函式來處理剛拿到的遠端資料，讓其依照順序一一呈現在網頁上。 每一篇文章都用一個 &lt;div&gt; 包起來 增加 class post 以套用 CSS 設定 依照順序把文章的標題跟內容放進去 網頁讀取時先呼叫一次，這時候會顯示我們預設的五篇文章數。 1234567891011121314151617async function showPosts() { const posts = await getPosts(); posts.forEach(post =&gt; { const postEl = $('&lt;div&gt;&lt;/div&gt;').appendTo(postsContainer); postEl.addClass('post'); postEl.html(` &lt;div class=&quot;number&quot;&gt;${post.id}&lt;/div&gt; &lt;div class=&quot;post-info&quot;&gt; &lt;h2 class=&quot;post-title&quot;&gt;${post.title}&lt;/h2&gt; &lt;p class=&quot;post-body&quot;&gt;${post.body}&lt;/p&gt; &lt;/div&gt; `); });}showPosts(); 讀取動畫當滑到頁尾時，我們增加一個讀取的顯示，用 JS 切換 class 中 opacity 的屬性，來操控它的顯示。 HTML 12345&lt;div class=&quot;loader&quot;&gt; &lt;div class=&quot;circle&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circle&quot;&gt;&lt;/div&gt;&lt;/div&gt; CSS 123.loader { opacity: 0; /* 隱藏} 123.loader.show { opacity: 1; /* 顯示} 再來我們增加點動畫效果，讓它做到上下的位移，並且是依序跳動的 123456789101112131415161718192021.circle { animation: bounce 0.5s ease-in infinite;}.circle:nth-of-type(2) { animation-delay: 0.1s;}.circle:nth-of-type(3) { animation-delay: 0.2s;}@keyframes bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); }} 顯示文章對瀏覽器中的視窗監控 scroll 事件，當瀏覽器滾動到頁尾時觸發函式，當動畫顯示 1 秒後會移除，接著間隔 0.3 秒後從遠端讀取文章資料並顯示在頁面上。 1234567891011121314151617181920function showLoading() { loading.addClass('show'); setTimeout(() =&gt; { loading.removeClass('show'); setTimeout(() =&gt; { page++; showPosts(); }, 300); }, 1000);}$(window).scroll(function() { const { scrollTop, scrollHeight, clientHeight } = document.documentElement; if (scrollTop + clientHeight &gt;= scrollHeight - 5) { showLoading(); }}); 這邊說明一下 scrollTop、clientHeight、scrollHeight 之間的關係 scrollTop : 是「內容」被捲動的距離，也就是內容頂端和捲軸頂端的相對距離，代表在有滾動條時，滾動條向下滾動的距離也就是元素頂部被遮住部分的高度。 clientHeight : 包括 padding 但不包括 border、水平滾動條、margin 的元素的高度。 scrollHeight : 和 clientHeight 屬性類似，但包含滾動 ( 隱藏 ) 的部分。 了解之後我們知道完整的內容高度 (scrollHeight) = 內容頂端和捲軸頂端的距離 (scrollTop) + 內容本身高度(clientHeight)，所以當滑到頁尾時也就是 (scrollTop + clientHeight &gt;= scrollHeight - 5) 會觸發產生新的文章，而之所以會 scrollHeight -5 是希望在接近底時就能夠觸發。 搜尋文章透過監聽搜尋欄位的 input 觸發搜尋的功能，indexOf() 方法會回傳某個指定的字符串值在字符串中首次出現的位置，如果沒有找到則回傳 -1，對此我們將符合的文章顯示，不符合的則隱藏，toUpperCase() 則是方便我們搜尋，可以忽略大小寫的輸入。 1234567891011121314151617function filterPosts(e) { const term = e.target.value.toUpperCase(); const posts = document.querySelectorAll('.post'); posts.forEach(post =&gt; { const title = post.querySelector('.post-title').innerText.toUpperCase(); const body = post.querySelector('.post-body').innerText.toUpperCase(); if (title.indexOf(term) &gt; -1 || body.indexOf(term) &gt; -1) { post.style.display = 'flex'; } else { post.style.display = 'none'; } });}document.getElementById('filter').addEventListener('input', filterPosts); 參考資料 JavaScript Promise 全介紹 Async function / Await 深度介紹 CSS 動畫 Cheetsheet - Element size and scrolling","link":"/2021/01/13/JavaScript-Infinite-Scroll-Blog/"},{"title":"[實作] JavaScript - Music Player","text":"成品Music Player 介紹使用 Web Audio API 做的播放器練習。 功能播放時旋轉封面圖片、顯示歌曲詳細資訊以及播放條，可切換上一首 \\ 下一首 或是快轉至點擊處播放，歌曲結束時自動播放下一首。 載入歌曲 播放和暫停功能 切換歌曲功能* 顯示播放進度條 點擊進度條播放 載入歌曲Web Audio API 可於網頁上操作並播放歌曲，在 HTML 部分使用 &lt;audio&gt;&lt;/audio&gt; tag 就可以播放音樂，播放器的 icon 使用 Font Awesome 呈現。 在播放前我們先設置歌曲的初始狀態，把要播放的歌曲放入陣列中供我們讀取，並設置初始索引值決定從哪首歌曲開始播放，並載入相對應的音訊檔和封面照片。 補充說明一下使用 jQuery 語法抓取元素時會得到一個陣列型態的 jQuery 物件，需要用 get() 轉換為 JavaScript DOM 元素之後再操作。 1234const audio = $('#audio').get();const audio = $('#audio').get(0); // get 後面接的是索引值，索引值由 0 開始const audio = $('#audio')[0]; // 也可以這樣寫 HTML 12345678910111213&lt;audio id=&quot;audio&quot;&gt;&lt;/audio&gt;&lt;div class=&quot;navigation&quot;&gt; &lt;button id=&quot;prev&quot; class=&quot;action-btn&quot;&gt; &lt;i class=&quot;fas fa-backward&quot;&gt;&lt;/i&gt; &lt;/button&gt; &lt;button id=&quot;play&quot; class=&quot;action-btn action-btn-big&quot;&gt; &lt;i class=&quot;fas fa-play&quot;&gt;&lt;/i&gt; &lt;/button&gt; &lt;button id=&quot;next&quot; class=&quot;action-btn&quot;&gt; &lt;i class=&quot;fas fa-forward&quot;&gt;&lt;/i&gt; &lt;/button&gt;&lt;/div&gt; JavaScript 1234567891011121314const audio = $('#audio')[0];const title = $('#title');const cover = $('#cover')[0];let songIndex = 2;const songs = ['acousticbreeze', 'allthat', 'beyondtheline', 'creativeminds', 'onceagain'];function loadSong(song) { title.text(song); audio.src = `music/${song}.mp3`; cover.src = `images/${song}.jpg`;}loadSong(songs[songIndex]); 播放和暫停功能播放和暫停其實很相像，當按下播放時增加 play 的 class ，然後把播放的按鈕換成暫停的樣式，接著執行音訊檔的播放。暫停則反之。 之後我們要做的就是按鈕的監聽，看是否有 play 這個 class 而決定我們要執行哪個函式。 123456789101112131415161718192021222324252627function playSong() { $('#music-container').addClass('play'); playBtn.find('i.fas').removeClass('fa-play'); playBtn.find('i.fas').addClass('fa-pause'); audio.play();}// Pause songfunction pauseSong() { $('#music-container').removeClass('play'); playBtn.find('i.fas').addClass('fa-play'); playBtn.find('i.fas').removeClass('fa-pause'); audio.pause();}// Event listenerplayBtn.click(function() { const isPlaying = $('#music-container').hasClass('play'); if (isPlaying) { pauseSong(); } else { playSong(); }}); 切換歌曲功能由於我們的歌曲資料是放在陣列中，切換歌曲時只需要去改變我們要讀取的索引值就好，要注意當我們一直往前一首播放時，要判斷是否已經超過第一首 ( 索引值為 0)，如果是的話就播放最後一首，往下一首播放反之。 接著綁定前一首 \\ 下一首 的按鈕監聽，再執行對應的函式。 而當歌曲播放結束時我們也需要呼叫函式來播放下一首，這時需要用到 audio 的 ended 屬性，來看歌曲播放是否結束，監聽歌曲是否結束來播放下一首歌曲。 123456789101112131415161718192021222324252627282930313233343536function prevSong() { songIndex--; if (songIndex &lt; 0) { songIndex = songs.length - 1; } loadSong(songs[songIndex]); playSong();}// Next songfunction nextSong() { songIndex++; if (songIndex &gt; songs.length - 1) { songIndex = 0; } loadSong(songs[songIndex]); playSong();}// Event LinstenerprevBtn.click(function() { prevSong();});nextBtn.click(function() { nextSong();});$('#audio').bind('ended', function() { nextSong();}); 顯示播放進度條這邊需要用到 Web Audio API 中的幾個屬性 duration ( 持續時間 ): 返回當前媒體的長度 currentTime ( 當前時間) : 設置或返回媒體中的當前播放位置 timeupdate ( 時間更新 ) : 當前播放位置發生變化時觸發 分別取得歌曲目前播放長度和歌曲總長度，接著將兩者相除 * 100 就會得到目前長度的百分比數值，之後對歌曲綁定時間更新的事件去觸發，不斷的去改變我們的容器寬度，就達成進度條的功能。 12345$('#audio').bind('timeupdate', function() { const { duration, currentTime } = audio; const progressPercent = (currentTime / duration) * 100; progress.css('width', `${progressPercent}%`);}); 點擊進度條播放這邊的概念跟顯示播放進度很類似，我們取得滑鼠點擊進度條的位置，看他佔整個進度條寬度的百分比，之後乘上歌曲的總長度，得到我們要播放歌曲的位置。 這邊用圖輔助說明，首先要取得滑鼠點擊位置，jQuery 中沒有 offsetX 屬性，所以我們用 offset()、pageX 來代替 $(e.target).offset().left 可以抓被點到的元素離頁面左邊的位置 e.pageX 可以抓當下被點到位置距離頁面左邊 用 pageX - clickX 就可以得到滑鼠點擊的位置 把 (pageX - clickX) / width ( 進度條的寬度 ) * duration 等於我們滑鼠點擊歌曲要播放的位置 123456789$('#progress-container').click(function(e) { const width = $('#progress-container').width(); const clickX = $(e.target).offset().left; const pageX = e.pageX; const duration = audio.duration; audio.currentTime = ((pageX - clickX) / width) * duration;}); 參考資料JS30-Day11-Custom Video Player","link":"/2021/01/21/JavaScript-Music-Player/"},{"title":"[筆記] JavaScript - Scope ( 作用域 )","text":"什麼是 Scope？w3c 的定義：「Scope determines the accessibility (visibility) of variables.」 Scope ( 作用域 ) 決定了變數可以被取用 ( 可視 ) 的範圍，其中又分為 Global Scope ( 全域作用域 ) 跟 Local Scope ( 區域作用域 )。 Global Scope ( 全域作用域 )在函式或區塊 {} 外宣告的變數，可以在全域使用，又稱全域變數。 12345678var carName = &quot;Volvo&quot;;myFunction(); function myFunction() { console.log(carName); // Volvo}console.log(carName); // Volvo myFunction() 內找不到 carName 就會到外面找，直到全域變數為止。 除了在外層宣告變數外，如果賦值給未宣告的變數會變成全域變數，要避免這種寫法。 12345function myFunction() { carName = &quot;Volvo&quot;;}myFunction();console.log(carName); // Volvo 要先執行 myFunction() 才宣告 carName 這個變數，因此沒有執行的話就 console 會拋出錯誤。 Local Scope ( 區域作用域 )在函式或是區塊內宣告的變數，只能在函式或是區塊中使用，又稱區域變數。 1234567myFunction();function myFunction() { var carName = &quot;Volvo&quot;; console.log(carName); // Volvo}console.log(carName); // not defined 參考資料 w3c - JavaScript Scope 重新認識 JavaScript: Day 10 函式 Functions 的基本概念","link":"/2021/04/15/JavaScript-Scope/"},{"title":"[實作] JavaScript - New Year Countdown","text":"成品New Year Countdown 介紹參考 JavaScript 30 中 Countdown Timer 的練習，利用 Date() 物件做的練習。 功能倒數現在離元旦剩餘的時間，主要處理可以分為以下幾個部分 設置倒數時間 計算剩餘時間 顯示時間 倒數與停止倒數 設置倒數時間因為是做跨年倒數，所以先用 getFullYear() 取得現在年份，再設置倒數時間，如果是做限時的倒數器直接設置倒數時間即可 12const currentYear = new Date().getFullYear(); const countDownDate = new Date(`January 01 ${currentYear + 1} 00:00:00`) 計算剩餘時間再來我們要計算剩餘時間，用 newDate() 取得現在時間，然後把倒數時間跟現在時間相減取得剩餘時間，然後把得到的時間 (millisecond) 轉換成天數、小時、分鐘跟秒。 把得到的豪秒數轉換成秒：result / 1000 將總秒數除以 60 取餘數，就是計算完分鐘術後剩下的秒數：(result / 1000) % 60 用 Math.floor 取最大整數：Math.floor(result / 1000) % 60 分鐘、小時、天數一樣的邏輯 宣告變數，利用 getElementById() 來取得 HTML 內的元素 1234const seconds = document.getElementById(&quot;seconds&quot;);const minutes = document.getElementById(&quot;minutes&quot;);const hours = document.getElementById(&quot;hours&quot;);const days = document.getElementById(&quot;days&quot;); 計算部分 1234567891011121314function remainTime() { const timeNow = new Date(); const result = countDownDate - timeNow; const s = Math.floor(result / 1000) % 60; const m = Math.floor(result / 1000 / 60) % 60; const h = Math.floor(result / 1000 / 60 / 60) % 24; const d = Math.floor(result / 1000 / 60 / 60 / 24); seconds.innerHTML = formatTime(s); minutes.innerHTML = formatTime(m); hours.innerHTML = formatTime(h); days.innerHTML = d;} 顯示時間在時間不是雙位數時增加前導零顯示，像是 9 秒時就會顯示 09，在數字小於 10 時於開頭加個字串 0。 123function formatTime(time) { return time &lt; 10 ? `0${time}` : time;} 倒數與停止倒數使用 setInterval 、 clearInterval 方法來實現倒數與停止倒數，setInterval 每隔一秒呼叫我們的函式，進而達到倒數的功能，當倒數時間到時我們呼叫 clearInterval 來終止倒數的功能。 123456789const intervalId = setInterval(() =&gt; { const result = countDownDate - (new Date()); if (result &lt; 0) { clearInterval(intervalId); } else { remainTime(); } }, 1000);","link":"/2020/12/24/JavaScript-NewYear-Count-Down/"},{"title":"[實作] JavaScript - Sortable List","text":"成品台灣必吃小吃 TOP10 介紹使用 jQuery UI - Sortable 做的可拖曳列表練習。 功能透過拖曳排序列表中的內容，可檢查清單的排序是否正確。 隨機排序列表中的內容 拖曳功能 檢查排序 隨機排序列表中的內容首先將我們的資料放入陣列中方便後續處理 123456789101112const famousFood = [ '牛肉麵', '小籠包', '滷肉飯', '大腸麵線', '蚵仔煎', '臭豆腐', '雞排', '珍珠奶茶', '刨冰', '鳳梨酥']; 接著將剛剛的陣列用 展開運算子 ... 將陣列展開成多個資料，然後將每筆資料都用 &lt;li&gt; 包起來，再放到各自的 &lt;ul&gt; 裡顯示在頁面上。 12345678910111213141516171819function creatList() { [...famousFood] // 排名的 list const orderItem = $('&lt;li&gt;&lt;/li&gt;').attr('data-index', index); orderItem.html(` &lt;span class=&quot;number&quot;&gt;${index + 1}&lt;/span&gt; `) // 食物的 list const foodItem = $('&lt;li&gt;&lt;/li&gt;').attr('data-index', index); foodItem.html(` &lt;div class=&quot;draggable&quot;&gt; &lt;p class=&quot;food-name&quot;&gt;${food}&lt;/p&gt; &lt;i class=&quot;fas fa-grip-lines&quot;&gt;&lt;/i&gt; &lt;/div&gt; `); $('#order-list').append(orderItem); $('#draggable-list').append(foodItem); });} 我們想要打亂每筆資料的排序位置，好讓之後可以進行拖曳排名的動作，利用 map() 將原陣列新增屬性 sort 並賦予值 Math.random() 以方便我們排序，再用 sort() 對剛賦予的 sort 值去排列，接著用 map() 整理陣列。 12345function creatList() {[...famousFood].map(data =&gt; ({ value: data, sort: Math.random() })).sort((a, b) =&gt; a.sort - b.sort).map(data =&gt; data.value) 拖曳功能我們使用 jQuery UI - Sortable 把對象綁定清單的父元素也就是 &lt;ul&gt; ，就能對下層的 &lt;li&gt;&lt;/li&gt; 進行拖曳排序的動作。 12$('#draggable-list').sortable();$('#draggable-list').disableSelection(); 紀錄一下這次學習到相關的事件用法 12345678910$('#draggable-list').sortable({ // 排序開始時觸發 start: function( event, ui ) { // 想要執行的內容... }, // 停止排序且 DOM 位置更改時觸發 update: function(e, ui) { foodName = ui.item.text(); // 取得被拖曳的元素文字 }}); 想用原生 JavaScript 的話參考 HTML Drag and Drop API 會需要以下幾個事件： dragstart : 開始拖曳一個元素時觸發 dragover : 一個元素被拖曳經過一個有效的放置目標時觸發 dragenter : 一個元素被拖曳進入一個有效的放置目標時觸發 dragleave : 一個元素被拖曳離開一個有效的放置目標時觸發 drop : 一個元素被放置於一個有效的放置目標時觸發 檢查排序這邊我們對清單中的每一個項目 li 去比對食物名稱是否和我們原本陣列 famousFood 中的相符，相符就加上 right 的 class 名稱，文字會變綠色表示正確，不相符就加上 wrong 的 class 名稱，文字會變紅色表示錯誤。 12345678910111213function checkOrder() { const draggableList = $('#draggable-list li') draggableList.each((index, listItem) =&gt; { const foodName = listItem.querySelector('.draggable').innerText.trim(); if (foodName !== famousFood[index]) { listItem.classList.remove('right'); listItem.classList.add('wrong'); } else { listItem.classList.remove('wrong'); listItem.classList.add('right'); } });} 參考資料 jQuery UI - Sortable HTML Drag and Drop API","link":"/2021/01/29/JavaScript-Sortable-List/"},{"title":"[實作] JavaScript - Typing Game","text":"成品Typing Game 介紹串接 Random Word 、臺北市立動物園_動物資料 API 並用 jQuery 語法做的練習。 功能畫面會顯示隨機的單字，輸入正確後得分並增加時間，有三種難度可選擇，難度高答對後增加的時間較少，時間到即停止。 從 API 中產生隨機單字 計時器倒數時間 輸入正確後根據難度增加一定的時間 將難度儲存至 localStorage 從 API 中產生隨機單字使用 fetch() 取得 Random Word、臺北市立動物園_動物資料 的資料當作我們隨機產生的單字來源，難度簡單的話使用 Random Word 的資料，中等跟困難的話則使用 臺北市立動物園_動物資料 ，取得資料後透過 json() 處理檔案，接著傳遞到下一層，動物資料我們擷取 A_Name_Latin 拉丁名字作為我們的單字。 函數 Math.random() 會隨機產生出 0~1 之間的小數，最大不會超過 1，而 length 則回傳陣列中包含的筆數，把兩個相乘可以得到一個最大不會超過該陣列資料筆數的小數，假設我們今天陣列中有 2 筆資料，兩者所相乘的結果是一個不會大於 2 的小數。 Math.floor 會回傳小於等於所給數字的最大整數，假設剛相乘完的結果是 39.9，那麼我們就可以抓取陣列中第 39 筆資料中的拉丁名字作為我們的單字。 123456789101112131415161718function simpleWords() { fetch('https://random-word-api.herokuapp.com/word?number=1') .then(res =&gt; res.json()) .then(data =&gt; { randomWord = data[0]; $('h1').text(randomWord); })}function hardWords() { fetch('https://data.taipei/api/v1/dataset/f18de02f-b6c9-47c0-8cda-50efad621c14?scope=resourceAquire') .then(res =&gt; res.json()) .then(data =&gt; { const words = data.result.results; randomWord = words[Math.floor(Math.random() * words.length)].F_Name_Latin; $('h1').text(randomWord); })} 計時器倒數時間setInterval 每隔一秒呼叫我們的函式，進而達到倒數的功能，當倒數時間到時我們呼叫 clearInterval 來終止倒數的功能。 123456789101112function countDownTime() { $('#time').text(`${time}s`); time--;}const intervalid = setInterval(() =&gt; { if (time &lt; 0) { clearInterval(intervalid); } else { countDownTime(); }}, 1000) 輸入正確後根據難度增加一定的時間對輸入欄位作事件監聽，如果輸入的與顯示的單字相符，那麼計分會 +1，清空輸入欄位並顯示下一組單字，用 if...else 迴圈判斷所選擇的難度，並增加相對應的時間。 12345678910111213141516171819202122$('input').keyup(function() { const answer = $(this); if (answer.val() === randomWord) { if (difficulty === 'easy') { simpleWords(); } else { hardWords(); } score++; $('#score').text(score); answer.val(''); if (difficulty === 'easy') { time += 5; } else if (difficulty === 'medium') { time += 10; } else { time += 8; } countDownTime(); }}) 將難度儲存至 localStorage對我們表單中的下拉式選單作監聽，也就是難度選擇的地方，取得值之後用 localStorage.setItem() 儲存，並用 localStorage.getItem() 讀取，而一開始 localStorage 中沒有值時我們預設難度為 easy。 HTML 12345678910&lt;form id=&quot;settings-form&quot;&gt; &lt;div&gt; &lt;label for=&quot;difficulty&quot;&gt;Difficulty&lt;/label&gt; &lt;select id=&quot;difficulty&quot;&gt; &lt;option value=&quot;easy&quot;&gt;Easy&lt;/option&gt; &lt;option value=&quot;medium&quot;&gt;Medium&lt;/option&gt; &lt;option value=&quot;hard&quot;&gt;Hard&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;/form&gt; JavaScript 1234567$('#settings-form').change(function() { difficulty = $('#difficulty').val(); localStorage.setItem('difficulty', difficulty)})let difficulty = localStorage.getItem('difficulty') !== null ? localStorage.getItem('difficulty') : 'easy';$('#difficulty').val(difficulty);","link":"/2021/01/23/JavaScript-Typing-Game/"},{"title":"[實作] JavaScript - Speak Number Guess","text":"成品Speak Number Guess 介紹使用 Web SpeechRecognition API 做的猜數字遊戲。 功能數字猜謎遊戲，每次會隨機指定一個數字 ( 範圍 1~100 ) 為終極密碼，透過麥克風猜數字縮小範圍，並會顯示目前範圍，猜對後顯示終極密碼並結束遊戲。 隨機產生終極密碼 取得語音輸入 顯示數字範圍 顯示遊戲結束 隨機產生終極密碼用 Mathrandom() 和 Math.floor() 取得隨機小數後乘上 100，這時候數字的範圍是 0 ~ 99，最後要 +1 才是我們要的範圍。 1234// Generate random numberfunction randomNumber() { return Math.floor(Math.random() * 100) + 1;} 取得語音輸入這邊先介紹會用到的幾個 Web SpeechRecognition API 的方法跟屬性 : SpeechRecognition.start() : 啟動語音辨識，以偵聽傳入的音頻 end 事件: 會在語音辨識結束時觸發 result 事件 : 會在語音辨識回傳結果時被觸發 目前因為每個瀏覽器的支援不一樣，要確保可以使用要將 webkit 標頭的 webkitSpeechRecognition 指定給該全域變數，方便我們使用。 之後透過start() 啟動語音辨識，並監聽 result 來取得我們要的資料作後續處理。觀察可以發現 results 中的 transcript 是語音輸入所辨識的數字，之後我們會拿這個跟終極密碼去比較。 123456window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;let recognition = new SpeechRecognition();recognition.start();recognition.addEventListener('result', onSpeak); 顯示數字範圍先看一下我們辨識語音後 HTML 的格式， &lt;span&gt; 標籤內放的是我們猜的數字，後面的 &lt;div&gt; 則會顯示數字的範圍。 1234567&lt;div id=&quot;msg&quot; class=&quot;msg&quot;&gt; &lt;!-- sample HTML &lt;div&gt;You said:&lt;/div&gt; &lt;span class=&quot;box&quot;&gt;Guessed number&lt;/span&gt; &lt;div&gt;number range&lt;/div&gt; --&gt; &lt;/div&gt; 把剛觀察後我們要的資料拿出來，接著要判斷的可以分為三個部分 : 判斷是否為數字 : 用 parseInt() 剛把得到的資料轉型為數字，若無法轉換為數字會回傳 NaN，如果不是數字的話顯示 That is not a valid number 判斷數字的範圍，如果超出範圍顯示 Number must be between 1 and 100 判斷數字和終極密碼之間的大小關係，進而縮減數字的範圍並顯示出來 最後監聽 end 事件，以便一直辨識語音直到我們答對為止。 12345678910111213141516171819202122232425262728293031function onSpeak(e) { const msg = e.results[0][0].transcript; checkNumber(msg);}function checkNumber(msg) { const number = parseInt(msg); $('#msg').html(` &lt;div&gt;You said: &lt;/div&gt; &lt;span class=&quot;box&quot;&gt;${msg}&lt;/span&gt; `) if (isNaN(number)) { $('#msg').append(`&lt;div&gt;That is not a valid number&lt;/div&gt;`); } else if (number &gt; 100 || number &lt; 1) { $('#msg').append(`&lt;div&gt;Number must be between 1 and 100&lt;/div&gt;`) } else if (number === finalNumber) { $('body').html(` &lt;h2&gt;Congrats! You have guessed the number! &lt;br&gt;&lt;br&gt; It was ${number}&lt;/h2&gt; &lt;button class=&quot;play-again&quot; id=&quot;play-again&quot;&gt;Play Again&lt;/button&gt; `) } else if (number &gt; finalNumber) { max = number; $('#msg').append(`&lt;div&gt;The number is between ${min} - ${max}&lt;/div&gt;`); } else { min = number; $('#msg').append(`&lt;div&gt;The number is between ${min} - ${max}&lt;/div&gt;`); }} 顯示遊戲結束遊戲結束後的畫面如下，顯示最後的終極密碼並有個按鈕可以再玩一次，對此我們對按鈕綁定點擊事件已觸發網頁刷新。 HTML 1&lt;button class=&quot;play-again&quot; id=&quot;play-again&quot;&gt;Play Again&lt;/button&gt; JavaScript 12345$('body').click(function(e) { if (e.target.id == 'play-again') { window.location.reload(); }}); 參考資料 MDN SpeechRecognition","link":"/2021/01/22/JavaScript-Speak-Number-Guess/"},{"title":"[筆記] 用 JavaScript 印出各種圖形","text":"JavaScript 的基礎應用，記錄一下當初解題的過程。 直角三角形 12345*************** 思考邏輯 依照層數輸出 * 輸出 * 後換行 實際程式碼 12345678910let n = 5; // 層數let output = '';for (i = 0; i &lt; n; i++) { let content = ''; for (j = 0; j &lt;= i; j++) { content += '*'; } output += content + '\\n';}console.log(output); 內層的 for 迴圈負責輸出 *，依照層數 n 輸出相對應的 * 數量，所以控制條件 j&lt;=i。 123for (j = 0; j &lt;= i; j++) { content += '*';} 外層 for 迴圈負責控制層數 n，將輸出的 * 儲存並換行。 12345for (i = 0; i &lt; n; i++) { let content = ''; for (j = 0; j &lt;= i; j++) {...} output += content + '\\n';} 直角三角形加強版 123456789************************* 思考邏輯 分成上下兩部份 輸出倒立的直角三角形 實際程式碼 1234567891011121314151617let n = 5; // 層數let output = '';for (i = 0; i &lt; n; i++) { let content = ''; for (j = 0; j &lt;= i; j++) { content += '*'; } output += content + '\\n';}for (i = n - 1; i &gt; 0; i--) { let content = ''; for (j = 0; j &lt; i; j++) { content += '*'; } output += content + '\\n';}console.log(output); 這個三角形可以拆為兩個直角三角形，我們要額外處理下半部的倒立直角三角形。內層的 for 迴圈一樣依照層數輸出相對應的 *。 123for (j = 0; j &lt; i; j++) { content += '*';} 外層的 for 迴圈控制層數，從四層依序遞減為一層，所以初始值為 i = n - 1，一樣將輸出的 * 儲存並換行。 12345for (i = n - 1; i &gt; 0; i--) { let content = ''; for (j = 0; j &lt; i; j++) {...} output += content + '\\n';} 利用陣列儲存 這邊另一個方法是用陣列存起來，最後用 arr.join() 的方法將陣列所有元素用 \\n 串接合併成一個字串回傳。 1234567891011121314151617let n = 5; // 層數let output = [];for (i = 0; i &lt; n; i++) { let content = ''; for (j = 0; j &lt;= i; j++) { content += '*'; } output.push(content);}for (i = n - 1; i &gt; 0; i--) { let content = ''; for (j = 0; j &lt; i; j++) { content += '*'; } output.push(content);}console.log(output.join('\\n')) 等腰三角形 12345 * *** ***** **************** 思考邏輯 需要額外輸出空格 輸出的 * 每層增加 2 個 實際程式碼 12345678910111213let n = 5; // 層數let output = '';for (i = 0; i &lt; n; i++) { let content = ''; for (j = n - 1; j &gt; i; j--) { content += '&amp;ensp;'; } for (k = 1; k &lt;= 2 * i + 1; k++) { content += '*'; } output += content + '\\n';}console.log(output); 輸出的空格從第一層 4 格依序遞減為第五層的 0 格，初始值為層數 -1 j = n - 1，而空格只需要輸出到第四層而已，所以判斷條件為 j &gt; i。 123for (j = n - 1; j &gt; i; j--) { content += '&amp;ensp;';} 輸出的 * 從第一層 1 個接著每層多增加 2 個，初始值為 k = 1，判斷條件 k &lt;= 2 * i + 1。 123for (k = 1; k &lt;= 2 * i + 1; k++) { content += '*';} 菱形 ( 等腰三角形加強版 ) 123456789 * *** ***** **************** ******* ***** *** * 思考邏輯 分成上下兩部份 輸出倒立的等腰三角形 實際程式碼 1234567891011121314151617181920212223let n = 5; // 層數let output = '';for (i = 0; i &lt; n; i++) { let content = ''; for (j = n - 1; j &gt; i; j--) { content += '&amp;ensp;'; } for (k = 1; k &lt;= 2 * i + 1; k++) { content += '*'; } output += content + '\\n';}for (i = n - 1; i &gt; 0; i--) { let content = ''; for (j = n - 1; j &gt;= i; j--) { content += '&amp;ensp;'; } for (k = 1; k &lt;= 2 * i - 1; k++) { content += '*'; } output += content + '\\n';}console.log(output); 菱形可以拆分為兩個等腰三角形，用正立的等腰三角形的概念來處理下半部的等腰三角形。 外圍層數的 for 迴圈從四層開始，依序遞減為一層，初始值為 i = n - 1，判斷條件i &gt; 0。 1for (i = n - 1; i &gt; 0; i--) {...} 輸出的空格反過來從第一層 1 格依序增加為第四層的 4 格，初始值為 j = n - 1，判斷條件 j &gt;= i。 123for (j = n - 1; j &gt;= i; j--) { content += '&amp;ensp;';} 輸出的 * 反過來，初始值一樣為 k = 1，判斷條件則變成 k &lt;= 2 * i - 1。 123for (k = 1; k &lt;= 2 * i - 1; k++) { content += '*';}","link":"/2021/04/13/JavaScript-%E5%8D%B0%E5%87%BA%E5%90%84%E7%A8%AE%E5%9C%96%E5%BD%A2/"},{"title":"[筆記] Markdown語法","text":"Markdown 語法是什麼？ Markdown 是一種輕量級標記式語言，為了實現易讀易寫的特性 Markdown 語法全由標點符號所組成，讓它們看起來就像是所要表達的意思。 因為其易讀易寫的特性，目前許多網站都廣泛使用 Markdown 語法。 一、常用功能 Markdown語法：123456789101112斜體：在兩邊加上 *星號* 或是 _底線_粗體：在兩邊加上 **兩個星號** 或是 __兩個底線__也可以用 **星號 與 _底線_**刪除線：在兩邊加上 ~~兩個波浪~~引言(註解)：&gt; 換行：需在最後面+`兩個空白鍵`·· &gt; 先以··表示空白 顯示結果：斜體：在兩邊加上 星號 或是 底線 粗體：在兩邊加上 兩個星號 或是 兩個底線 也可以用 星號 與 底線 刪除線：在兩邊加上 兩個波浪 引用文字(註解)： 換行：需在最後面+兩個空白鍵··先以··表示空白 二、標題Markdown語法：12345678Markdown 提供了六種規格的，分別對應 Html 標籤中的`&lt;h1&gt; ~ &lt;h6&gt;`# H1## H2### H3#### H4##### H5###### H6 顯示結果：H1H2H3H4H5H6三、清單Markdown 支援無序清單和有序清單，要在清單下加入段落只要 +tab 就好。無序清單可使用星號、加號或是減號作為標記： Markdown語法：123* 無序清單+ 這也是清單- 這還是清單 顯示結果： 無序清單 這也是清單 這還是清單 有序清單則使用數字接一個英文句點： Markdown語法：121. 有序清單１2. 有序清單２ 顯示結果： 有序清單１ 有序清單２ 四、連結Markdown語法：1234567891011* 連結兩邊加上`&lt;` `&gt;`就會產生超連結 &lt;https://images.unsplash.com/photo-1584342864307-03dae979b7db?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=400&amp;q=80&gt; * 名稱兩邊加上`[` `]`然後再連結兩邊加上`(` `)`就可以將連結替換成文字連結 [傳送門](https://images.unsplash.com/photo-1584342864307-03dae979b7db?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=400&amp;q=80) * 將`[` `]`前+`!`，則可以產生圖片 (把滑鼠指向圖片可以看到註解） ![圖片參考名稱](https://images.unsplash.com/photo-1584342864307-03dae979b7db?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=400&amp;q=80 &quot;傳送門&quot;) 顯示結果： 連結兩邊加上&lt; &gt;就會產生超連結 https://images.unsplash.com/photo-1584342864307-03dae979b7db?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=400&amp;q=80 名稱兩邊加上[ ]然後再連結兩邊加上( )就可以將連結替換成文字連結 傳送門 將[ ]前+!，則可以產生圖片 (把滑鼠指向圖片可以看到註解） 五、程式碼123行內的 `程式碼` 用 `反引號` 包起來區塊的 `程式碼` 用 ```三個反引號```包起來記得要加上語言名稱 Markdown語法：12var s = &quot;JavaScript Syntax Highlighter&quot;;alert(s); 12$s = &quot;PHP Syntax Highlighter&quot;;echo $s; 顯示結果：12var s = &quot;JavaScript Syntax Highlighter&quot;;alert(s); 12$s = &quot;PHP Syntax Highlighter&quot;;echo $s; 參考資料Markdown 文件","link":"/2020/11/17/Markdown%E8%AA%9E%E6%B3%95/"},{"title":"[實作] 手刻切版 - Personal Resume","text":"成品Personal Resume Intro 網頁介紹這是一個個人作品集的網頁，最上方的 navbar 左側是個人的資訊，右側是文字及超連結跳轉頁面。 Home：由個人頭像、標語以及敘述組成，搭配一個背景色以及個人的社群。 About me：個人學歷、經歷區塊， Portfolio：利用交錯漂浮版面來放置個人作品，一邊是作品的圖示，另一邊說明作品內容。 Contact：分成三個區塊，由 icon、標題以及文字敘述組成。 最後則是footer。 Layout Notes開始前一樣先進行 reset 的動作，將所有的 margin、padding 歸零，並設定 box-sizing:border-box 讓 padding 和 border 的修改不會改變 box model 的大小。 12345678910111213141516* { -webkit-box-sizing: border-box; box-sizing: border-box; margin: 0; padding: 0;}body { font-family: 'Montserrat', sans-serif;}ul { margin: 0; padding-left: 0; list-style: none;} Navbar 左側是標題搭配敘述，右邊則是 ul 包住 li 當作 navbar 的選單，並增加改變顏色的效果，因為使用 float 排版，要分別設定標題跟 選單的浮動方向。 HTML 架構 12345678910111213141516&lt;div id=&quot;header&quot;&gt; &lt;div class=&quot;container clearfix&quot;&gt; &lt;div id=&quot;info&quot;&gt; &lt;h3 class=&quot;name&quot;&gt;&lt;b&gt;Nick &amp;thinsp; &lt;/b&gt;&lt;/h3&gt; &lt;span class=&quot;title&quot;&gt;&amp;frasl; &amp;thinsp; Becoming a Front-End Developer&lt;/span&gt; &lt;/div&gt; &lt;div id=&quot;nav&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#header&quot;&gt;home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#about&quot;&gt;about me&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#portfolios&quot;&gt;portfolio&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;contact&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS 部分 1234567891011121314#info { float: left; line-height: 40px;}#nav { float: right; text-transform: uppercase; line-height: 100px;}#nav li { float: left;} Home 接著個人頭像這邊練習用 flex 排版，可以分為背景色的橘色區塊、個人頭像的綠色區塊和標題的藍色區塊，然後把個人頭像的綠色區塊向左偏移達到重疊的效果。個人頭像照片的部分，則是用 border-radius:50% 去切出圓形來。 HTML 架構 123456789101112131415161718192021222324&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;bg&quot;&gt;&lt;/div&gt; &lt;div class=&quot;profile&quot;&gt; &lt;div class=&quot;avatar&quot;&gt; &lt;img src=&quot;images/avatar.jpg&quot; width=&quot;206&quot; height=&quot;206&quot; alt=&quot;avatar&quot;&gt; &lt;h3 class=&quot;name&quot;&gt;Nick&lt;/h3&gt; &lt;div class=&quot;title&quot;&gt;Becoming a Front-End Developer&lt;/div&gt; &lt;div class=&quot;social-media&quot;&gt; &lt;ul class=&quot;clearfix&quot;&gt; &lt;li&gt;&lt;a href=&quot;https://www.facebook.com/&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-facebook&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-github&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.linkedin.com/&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;fa fa-linkedin&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;self-intro&quot;&gt; &lt;h2&gt;Hello&lt;/h2&gt; &lt;div class=&quot;subtitle&quot;&gt; Looking for my next opportunity to make a change. &lt;/div&gt; &lt;p&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Aspernatur nihil quam cupiditate labore totam nostrum dolor, neque voluptatibus cum accusamus.&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; CSS 部分 12345678910111213141516171819202122232425262728293031323334#content&gt;.container { display: flex; width: 1170px; margin: auto;}.profile { width: 365px; position: relative; top: 33px; left: -25%;}.avatar { display: flex; flex-direction: column; align-items: center; width: 350px; height: 404px; background-color: #F2ECE8; padding-top: 30px; box-shadow: 5px 5px 50px #F2ECE8;}.self-intro { width: 45%; position: relative; left: -17em;}.avatar img { border: 1px solid transparent; border-radius: 50%;} About 個人學經歷區塊是鏡像對稱的兩個區塊，在區塊裡包含了時間、標題以及敘述，外邊加上陰影的效果。 HTML 架構 1234567891011121314151617181920212223&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;education&quot;&gt; &lt;h3 class=&quot;title&quot;&gt;Education&lt;/h3&gt; &lt;div class=&quot;timeline&quot;&gt; &lt;div class=&quot;timeline-item&quot;&gt; &lt;h6 class=&quot;date&quot;&gt; &lt;i class=&quot;fa fa-calendar&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; 2013 - 2015 &lt;/h6&gt; &lt;h4 class=&quot;title&quot;&gt;Master In Computer Science&lt;/h4&gt; &lt;p class=&quot;text&quot;&gt;Lorem, ipsum dolor sit amet consectetur adipisicing elit. Adipisci vero commodi reiciendis in rerum accusantium fugit vel nesciunt quos reprehenderit?&lt;/p&gt; &lt;h6 class=&quot;date&quot;&gt; &lt;i class=&quot;fa fa-calendar&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; 2011 - 2013 &lt;/h6&gt; &lt;h4 class=&quot;title&quot;&gt;Studie At delhi university&lt;/h4&gt; &lt;p class=&quot;text&quot;&gt;Lorem, ipsum dolor sit amet consectetur adipisicing elit. Adipisci vero commodi reiciendis in rerum accusantium fugit vel nesciunt quos reprehenderit?&lt;/p&gt; &lt;h6 class=&quot;date&quot;&gt; &lt;i class=&quot;fa fa-calendar&quot; aria-hidden=&quot;true&quot;&gt;&lt;/i&gt; 2008 - 2011 &lt;/h6&gt; &lt;h4 class=&quot;title&quot;&gt;Bachelor Degree&lt;/h4&gt; &lt;p class=&quot;text&quot;&gt;Lorem, ipsum dolor sit amet consectetur adipisicing elit. Adipisci vero commodi reiciendis in rerum accusantium fugit vel nesciunt quos reprehenderit?&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; CSS 部分 1234567891011121314151617.education { display: flex; flex-direction: column; width: 50%; margin-top: 30px; padding: 50px 20px;}.timeline { background: #fff; padding: 30px 15px; border: 1px solid #0000002c; border-radius: 10px; width: 100%; position: relative; box-shadow: 0px 0px 18px 0 #0000002c;} Portfolio 個人作品集使用交錯排版方式，一邊是作品的縮圖，另一邊說明作品，敘述欄加入了交錯的透明背景色。 HTML 架構 1234567891011121314151617181920&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;portfolio&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;https://picsum.photos/600/350?random=10&quot; alt=&quot;portfolio&quot;&gt; &lt;/div&gt; &lt;div class=&quot;portfolio-info&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;portfolio&lt;/h2&gt; &lt;p class=&quot;intro&quot;&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Corporis, odit.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;portfolio&quot;&gt; &lt;div class=&quot;portfolio-info&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;portfolio&lt;/h2&gt; &lt;p class=&quot;intro&quot;&gt;Lorem ipsum dolor sit amet consectetur adipisicing elit. Corporis, odit.&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;https://picsum.photos/600/350?random=10&quot; alt=&quot;portfolio&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS 部分 12345678910111213141516171819202122232425262728293031323334.portfolio { display: flex; align-items: center; margin-bottom: 70px;}.portfolio .thumbnail { width: 55%; flex-shrink: 0;}.portfolio .thumbnail img { width: 100%; vertical-align: middle;}.portfolio-info { width: 55%; flex-shrink: 0; padding: 50px 30px; position: relative; z-index: 1;}.portfolio&gt; :first-child { margin-right: -10%;}.portfolio:nth-child(2n+1) .portfolio-info { background-color: rgba(242, 236, 232, .8);}.portfolio:nth-child(2n) .portfolio-info { background-color: rgba(223, 225, 229, .8);} Contact Contact 部分是三個區塊分別代表三種聯絡方式，用 icon 加入標題和文字來呈現。 12345678910111213141516&lt;div class=&quot;container&quot;&gt; &lt;h2 class=&quot;catagory&quot;&gt;contact &amp;thinsp; &lt;em&gt;info&lt;/em&gt;&lt;/h2&gt; &lt;div class=&quot;contact method&quot;&gt; &lt;div class=&quot;contact-way&quot;&gt; &lt;div class=&quot;icon&quot;&gt; &lt;img src=&quot;https://img.icons8.com/bubbles/100/000000/cell-phone.png &quot; alt=&quot;phone&quot;&gt; &lt;/div&gt; &lt;div class=&quot;contact-info&quot;&gt; &lt;h1&gt;Phone&lt;/h1&gt; &lt;p&gt;TEL: +8862 1234-5678&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;contact-way&quot;&gt;..&lt;/div&gt; &lt;div class=&quot;contact-way&quot;&gt;..&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS 部分 1234567891011121314151617181920212223.contact.method { display: flex; width: 100%; flex-direction: row; justify-content: space-evenly; padding: 100px 0;}.contact-way { display: flex; width: 30%; margin: 0; padding: 30px; flex-direction: row; border-radius: 10px; box-shadow: 0px 0px 18px 0 #0000002c; transition: box-shadow .3s ease;}.contact-way:hover { box-shadow: 0px 0px 5px 0 #0000002c;}","link":"/2020/11/26/Personal-Resume/"},{"title":"[實作] shell環境安裝","text":"WSL 是什麼？Ｗindows Subsystem for Linux，簡稱 WSL，適用於 Linux 的 Windows 子系統，可在 Windows 上執行 Linux 環境。 安裝 WSL Step 1 - 啟用 WSL以系統管理員身分開啟 PowerShell 執行下面這段 1dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 確認執行完出現下列畫面 Step 2 - 更新至 WSL2先確認您的版本及組件號碼是否符合以下條件 Windows 標誌鍵 + R，輸入 winver 確認版本 X64 系統： 版本 1903 或更高版本，含組建 18362 或更高組建。 ARM64 系統： 版本 2004 或更高版本，含組建 19041 或更高組建。 低於 18362 的組建不支援 WSL 2。 使用 Windows 更新小幫手來更新您的 Windows 版本。 Step 3 - 啟用虛擬機功能一樣以系統管理員身分開啟 PowerShell 並執行： 1dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 確認執行完出現下列畫面 重新啟動電腦已完成 WSL並更新至 WSL2 Step 4 - 下載 Linux 核心更新套件WSL2 Linx 更新套件 Step 5 - 將 WSL2 設為預設版本一樣以系統管理員身分開啟 PowerShell 並執行： 1wsl --set-default-version 2 這部分出現以下錯誤，不過不影響之後的安裝 12wsl : 無法辨識 'wsl' 詞彙是否為 Cmdlet、函數、指令檔或可執行程式的名稱。請檢查名稱拼字是否正確，如果包含路徑的話，請確認路徑是否正確，然後再試一次。 安裝 Linux 發行版本從 Microsoft Store 上選取一個 Linux 發行版本，第一次啟動時需要設定使用者帳戶和密碼 設定完成畫面，之後想要重設密碼或忘記的話可以參考 這邊 參考資料在 windows10 安裝 bash&amp; oh-my-zsh 為新的 Linux 發行版本建立使用者帳戶和密碼","link":"/2020/11/19/shell%E7%92%B0%E5%A2%83%E5%AE%89%E8%A3%9D/"},{"title":"[實作] 手刻切版 - RootsSkate","text":"成品RootsSkate Intro 網頁介紹純 HTML&amp;CSS 切版練習，版面配置參考不少網站後自己編排，排版方面使用 float 進行排版。網站主要為販售滑板的網頁。總共有三個頁面：Home、About、Contact，每個頁面都在右下角有快速返回首頁的按鈕設計。 Home：基本 logo 圖、navbar，首圖和標語，接著是商品的資訊，最後則是 footer 以及社群 icon。 About：相同的 logo 圖、 navbar 以及 footer，接著是頁面的首圖與標語、品牌的介紹，人物介紹帶有簡易的動畫以及社群的功能。 Contact：相同的 logo 圖、 navbar 以及 footer，首圖部分則是利用 iframe 嵌入 google 地圖，側邊是關於商店的聯絡資訊以及營業時間，form 表單包含四個 input 一個 textarea，搭配一個 submit 的按鈕。 Layout Notes一開始需要先做 reset 的動作，可以在 CSS 設定或是直接引入 normalize.css 檔案來幫我們做 reset 的動作。 box-sizing: border-box; 這個設定是讓 padding 以及 border 的修改不會改變到 box model 的大小。 首先我們會做一些全域的設定，像是字型、大小、渲染時的平滑效果以及 ul 的設定。 123456789101112131415161718* { -webkit-box-sizing: border-box; box-sizing: border-box;}body { font-family: 'Source Sans Pro', sans-serif; font-size: 15px; font-weight: 400; -webkit-font-smoothing: antialiased; -moz-font-smoothing: antialiased;}ul { margin: 0; padding-left: 0; list-style-type: none;} Home 這邊要處理的分別是 logo 圖跟我們的 navbar，圖片的高度跟我們的 navbar 高度一樣而不會超出，另一邊用 ul 包住 li 當作 navbar 的選單，並增加改變顏色的效果，因為使用 float 排版，要分別設定圖片跟 navbar 的浮動方向。 HTML 架構 123456789101112131415&lt;div id=&quot;header&quot;&gt; &lt;div class=&quot;container clearfix&quot;&gt; &lt;div id=&quot;logo&quot;&gt; &lt;img src=&quot;images/ms-icon-144x144.png&quot; width=&quot;112&quot; height=&quot;100&quot; alt=&quot;Skater&quot;&gt; &lt;/div&gt; &lt;div id=&quot;nav&quot;&gt; &lt;ul class=&quot;clearfix&quot;&gt; &lt;li&gt;&lt;a href=&quot;index.html&quot;&gt;home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;about.html&quot;&gt;about&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;contact.html&quot;&gt;contact&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;icon-basket&quot;&gt;&lt;/i&gt;cart&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS 部分 123456789101112131415161718192021222324#logo { float: left;}#nav { float: right; text-transform: uppercase; line-height: 100px;}#nav li { float: left;}#nav a { padding: 0 12px; color: #333; text-decoration: none; font-size: 14px;}#nav a:hover { color: #d6b161;} 首圖是用整個區塊的背景圖片呈現，加上 h1 標題。 HTML 架構 12345&lt;div class=&quot;slider&quot;&gt; &lt;span&gt; &lt;h1&gt;explore &amp;emsp; dare &amp;emsp; wonder&lt;/h1&gt; &lt;/span&gt;&lt;/div&gt; CSS 部分 123456789101112131415161718slider { background-image: url(../images/cover.jpg); background-size: cover; background-position: 50% 50%; background-repeat: no-repeat; width: 100%; height: 550px; position: relative;}.slider span { position: absolute; margin: 0 auto; top: 56%; left: 28.5%; transform: translateY(-50%);} 商品的 showcase 和首圖概念一樣，用區塊的背景圖片去呈現，為了給左邊留白寬度沒有設定 100%，標題文字則用兩種顏色呈現，加入一個 a 連結的 button，並做了改變顏色的動畫。 HTML 架構 1234567&lt;div class=&quot;new-collection&quot;&gt; &lt;div class=&quot;container clearfix&quot;&gt; &lt;div class=&quot;title&quot;&gt;&lt;span class=&quot;golden-title&quot;&gt;new&lt;/span&gt;&lt;br&gt;colle-&lt;br&gt;ction&lt;/div&gt; &lt;a href=&quot;shop.html&quot; class=&quot;button link&quot;&gt;see all&lt;/a&gt; &lt;div class=&quot;background&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; CSS 部分 123456789101112131415161718192021222324252627282930313233343536373839.background { background-image: url(../images/collection.jpg); background-size: cover; background-position: 50% 100%; width: 89%; height: 450px; float: right; margin-top: -107px;}.new-collection .title { position: absolute; top: 120px; font-size: 70px; font-weight: bold; color: #000; text-transform: uppercase; letter-spacing: 15px; float: left;}.new-collection .golden-title { color: #d6b161;}.button.link { position: relative; top: 240px; padding: 15px 60px; background: #000; color: #fff; -webkit-transition: 0.2s linear all; transition: 0.2s linear all;}.button.link:hover { background: #d6b161; color: #fff;} 商品區塊分為三個欄位，排版上設定 float:left width:33.3%，內容則加入商品圖片、商品標題跟價格。 HTML 架構 123456789101112131415&lt;div class=&quot;products&quot;&gt; &lt;ul class=&quot;clearfix row&quot;&gt; &lt;li class=&quot;col-4 product&quot;&gt; &lt;div class=&quot;thumbnail&quot;&gt; &lt;img src=&quot;images/product-1.jpg&quot; alt=&quot;product&quot;&gt; &lt;/div&gt; &lt;div class=&quot;info&quot;&gt; &lt;h3 class=&quot;title&quot;&gt; &lt;a href=&quot;#&quot;&gt;World Industries Skateboard Graffiti&lt;/a&gt; &lt;/h3&gt; &lt;div class=&quot;price&quot;&gt;$149.99&lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; CSS 部分 1234.col-4 { float: left; width: 33.3333333%;} footer 分為左邊的 copyright 以及右邊的社群連結，一樣要分別設定個別的浮動方向。 社群連結是利用在 a 連結裡面放入圖片的方式呈現，在 css 方面設定 display:inline-blick 讓我們設定 width 跟 height 屬性。 HTML 架構 12345678910111213141516171819202122232425262728&lt;div id=&quot;footer&quot;&gt; &lt;div class=&quot;container clearfix&quot;&gt; &lt;div class=&quot;copyright&quot;&gt; &lt;div class=&quot;title&quot;&gt;Copyright &amp;copy; Just Skate 2020&lt;/div&gt; &lt;div class=&quot;subtitle&quot;&gt;Trademarks belong to their respective owners. All rights reserved.&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;social-media&quot;&gt; &lt;ul class=&quot;clearfix&quot;&gt; &lt;li&gt; &lt;a href=&quot;https://www.facebook.com/&quot; target=&quot;_blank&quot;&gt; &lt;img src=&quot;images/social-facebook.png&quot; alt=&quot;facebook&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;https://twitter.com/?lang=en&quot; target=&quot;_blank&quot;&gt; &lt;img src=&quot;images/social-twitter.png&quot; alt=&quot;twitter&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;https://www.instagram.com/&quot; target=&quot;_blank&quot;&gt; &lt;img src=&quot;images/social-instagram.png&quot; alt=&quot;instagram&quot;&gt; &lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS 部分 123456789101112131415161718192021#footer .copyright { float: left;}#footer .social-media { float: right;}#footer .social-media li { float: left;}#footer .social-media a { display: inline-block; margin: 10px; width: auto; height: 20px; line-height: 20px; text-align: center; text-decoration: none;} About About 頁面的首圖跟標語跟首頁一樣，用整個區塊的背景圖片呈現，加上 h1 標題。 HTML 架構 12345&lt;div class=&quot;header&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1 class=&quot;title&quot;&gt;our story&lt;/h1&gt; &lt;/div&gt;&lt;/div&gt; CSS 部分 123456789101112131415#content .header { padding: 200px 0; background-image: url(../images/about.jpg); background-size: cover; background-position: 50% 31%;}#content .header .title { float: left; margin: 0; color: #fff; text-transform: uppercase; font-weight: bold; letter-spacing: 2px; font-size: 24px;} 成員介紹分為標題 h2、敘述 p 以及下方的成員欄位，當滑鼠移到成員欄位時會有上移以及變色的效果。 HTML 架構 ( 這邊和首頁商品架構類似，只說明動畫部分 ) 12345678910111213141516&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;avatar&quot;&gt; &lt;img src=&quot;images/member-1.jpg&quot; alt=&quot;avatar&quot;&gt; &lt;/div&gt; &lt;div class=&quot;info&quot;&gt; &lt;h3 class=&quot;name&quot;&gt;Benjamin Parker&lt;/h3&gt; &lt;div class=&quot;title&quot;&gt;CEO &amp;amp; Co-Founder&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;social-media&quot;&gt; &lt;ul class=&quot;clearfix&quot;&gt; &lt;li&gt;&lt;a href=&quot;https://www.facebook.com/&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;icon-facebook&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://twitter.com/?lang=en&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;icon-twitter&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;https://www.linkedin.com/&quot; target=&quot;_blank&quot;&gt;&lt;i class=&quot;icon-linkedin&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; CSS 動畫部分 12345678910111213141516171819.about #content .member:hover .title { color: #fff;}.about #content .member:hover a { color: #fff;}.col-4.member { transform: translateY(0px); transition: .5s;}.col-4.member:hover { transform: translateY(-40px);}.col-4.member:hover .wrap { background-image: linear-gradient(0deg, #d6b161, #fff);} Contact Contact 頁面把首圖換成了 google map，主要是用 iframe 這個標籤來呈現，詳細使用方式可以參考網站嵌入google map技術，並給予高度跟寬度來調整呈現的樣子。 12&lt;iframe src=&quot;https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3614.9390098163053!2d121.56572361500625!3d25.03614378397135!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x3442ab43ab5a86c1%3A0x400f5859b70ce0b7!2zMTEw5Y-w5YyX5biC5L-h576p5Y2A5p2-5aO96LevMTPomZ8!5e0!3m2!1szh-TW!2stw!4v1573633685991!5m2!1szh-TW!2stw&quot; width=&quot;100%&quot; height=&quot;450&quot; frameborder=&quot;0&quot; style=&quot;border:0&quot; allowfullscreen&gt;&lt;/iframe&gt; 下方分為兩個區塊，分別是商店資訊區塊以及表單的區塊，文字部分是 h3 標題搭配 p 敘述，表單每個 div 都有 label input，在 Name 跟 Email 多加 required 要求一定要輸入相關資訊，寬度給予 100% 並加上 border。 HTML 架構：商店資訊 123456789101112&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-4 office-info&quot;&gt; &lt;h3 class=&quot;title&quot;&gt;our store&lt;/h3&gt; &lt;div class=&quot;contact-info&quot;&gt; &lt;p class=&quot;address&quot;&gt;No. 13, Songshou Rd., Xinyi Dist., Taipei City 110, Taiwan (R.O.C.)&lt;/p&gt; &lt;div class=&quot;info&quot;&gt;以下省略&lt;/div&gt; &lt;h3 class=&quot;title&quot;&gt;opening hour&lt;/h3&gt; &lt;div class=&quot;contact-info&quot;&gt; &lt;div class=&quot;weekday&quot;&gt;Monday - Friday: 11:00 - 19:30&lt;/div&gt; &lt;div class=&quot;holiday&quot;&gt;Saturday - Sunday: 11:00 - 20:00&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; HTML 架構：表單部分 1234567891011121314151617181920&lt;div class=&quot;col-8 question&quot;&gt; &lt;h3 class=&quot;title&quot;&gt;have questions?&lt;/h3&gt; &lt;p&gt;Please fill in the fields below: * = Required&lt;br&gt;We'll get back to you within 48-72 hrs.&lt;/p&gt; &lt;form action=&quot;#&quot; class=&quot;contact-form&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-6&quot;&gt; &lt;label for=&quot;name&quot;&gt;name *&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; required&gt; &lt;/div&gt; &lt;div class=&quot;col-6&quot;&gt; &lt;label for=&quot;email&quot;&gt;email *&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; id=&quot;email&quot; required&gt; &lt;div class=&quot;col-6&quot;&gt;以下省略&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-12&quot;&gt; &lt;label for=&quot;comments&quot;&gt;comments&lt;/label&gt; &lt;textarea name=&quot;comments&quot; id=&quot;comments&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt; CSS 表單部分 123456.contact-form input,.contact-form textarea { padding: 6px 12px; border: 1px solid #e5e5e5; width: 100%;} Go top Go-top 快速回到首頁按鈕，用 a 連結回到 #header 加上 icon 圖示呈現，position:fixed 的元素會相對於瀏覽器視窗來定位，即便頁面捲動，還是會固定在相同的位置。 1&lt;a href=&quot;#header&quot; id=&quot;go-top&quot;&gt;&lt;i class=&quot;icon-go-top&quot;&gt;&lt;/i&gt;&lt;/a&gt; 123456789101112#go-top { position: fixed; right: 20px; bottom: 35px; width: 40px; height: 40px; background: rgba(0, 0, 0, .6); color: #fff; text-align: center; line-height: 40px; text-decoration: none;}","link":"/2020/11/25/RootsSkate/"},{"title":"[筆記] JavaScript - Basic","text":"什麼是 JavaScript？ JavaScript是一門基於原型、函式先行的語言，支援物件導向設計 JavaScript 不是 Java，除了句法上有一些相似之處，JavaScript 和 Java 是完全不相干的 1995 年時，JavaScript 隨著 Netscape 2.0 首次推出，它原本要被命名為 LiveScript，但因為行銷策略為了強調昇陽的 Java 程式語言的普遍性，改名為 JavaScript，之後就造成了大家的混淆。 讓你在網頁中提供動態的功能，像是內容即時更新、影片播放、控制圖片等 瀏覽器唯一指定內建程式語言 概論以下引用自 Wikipedia 一般來說，完整的JavaScript包括以下幾個部分： ECMAScript，描述了該語言的語法和基本物件 文件物件模型（DOM），描述處理網頁內容的方法和介面 瀏覽器物件模型（BOM），描述與瀏覽器進行互動的方法和介面 JavaScript的基本特點如下： 是一種解釋性程式語言（代碼不進行預編譯） 主要用來向HTML頁面添加互動行為 可以直接嵌入HTML頁面，但寫成單獨的js檔案有利於結構和行為的分離 JavaScript常用來完成以下任務： 嵌入動態文字於HTML頁面 對瀏覽器事件作出回應 讀寫HTML元素 在資料被提交到伺服器之前驗證資料 檢測訪客的瀏覽器資訊 控制cookie，包括建立和修改等 語言特性 動態型別語言： 弱型別語言：不用特別宣告變數的型別，在運作時會自動轉換，比如直接將整數變數與字串變數相加 物件導向 Primitive Types Object Types HTTP 請求方法與 HTTP 動詞 用動詞標準化動作 (HTTP Method) GET POST DELETE PUT PATCH 用狀態碼標準化結果 (HTTP Status code) 1xx: 稍等 2xx: 成功 3xx: 重新導向 (301 永久導向、302 暫時導向、304 未修改) 4xx: Client 端錯誤 (404 拒絕存取、403 禁止使用、404 找不到) 5xx: Server 端錯誤 變數 (Variable)變數是用來儲存資料和進行運算的基本單位，在 JavaScript 中變數宣告有一定的規則，變數的第一個字母必須為英文字母、底線 _ 或是錢字號 $ ，後面可以是英文字母、底線 _ 或是錢字號 $ 以及數字。 變數名稱不可以是保留字 (Reserved Words) 與關鍵字 (keyword) 關鍵字指的是 ECMAScript 所規定具有特定用途的英文單字，不能用來作為變數名稱使用。 而保留字則是雖然目前在 JavaScript 還沒有特殊用途，但在未來有可能會被拿來當關鍵字來使用，所以也不能作為變數名稱。 MDN 關鍵字與保留字列表 資料型別 (Data types) 六種基本 (primitives) 資料型別 : Number : 整數或是帶有小數點的浮點數 特殊型 : Infinity、-Infinity、NaN (Not a Number) String : 字串，用一組 ' ' 或 &quot; &quot; 包住，不可混用，ES6 可以用 `` 來宣告 Boolean : true and false null : 表示空值的特殊值 undefined : 表示值還沒有定義或還未指定 Symbol : ES6 新語法，用來建立獨一無二的值 物件型別 (Object): 除基本型別外都是物件型別 可以透過 typeof 運算子來判斷型別 1234typeof true; // 'boolean'typeof '123'; // 'string'typeof 123; // 'number'typeof [ ]; // 'object' 浮點數的陷阱JavaScript 的 number 是基於「IEEE 754」二進位浮點數算術標準，所以當你執行 0.1 + 0.2 === 0.3 的時候，你會得到 false 的結果，不過執行 0.2 + 0.3 === 0.5 會得到 true的結果。 因為十進位的小數無法完美的用二進位的方式表示，只能用無限循環的位數來趨近於十進位的小數，若以 IEEE 754 規定的 24 位數為上限時，在儲存時就會省略一些位數，導致還原時的小數不夠精準。 運算式與運算子 (Expression &amp; Operator)JavaScript 的語法基本上可以分為兩大類，「敘述句 (Statement)」 與 「運算式 (Expression)」 敘述句 (Statement)：簡單來說就是執行某個動作。像是變數的宣告、賦值，迴圈和 if 判斷式等等都可以被歸類於此。 1var a; 運算式 (Expression)：而運算式最大的特性，就是它會產生一個「值」。像是我們在呼叫 function 時的參數 (arguments)，或者透過 = 賦值時，在 = 「右側」的部分都屬於運算式的部分。 1var a = 10 * 10; = 右側的 10 * 10 就是運算式，而 10 則為運算元 運算子 (Operators) *算術運算子 (Arithmetic Operators)**：以數值 ( 文字或變數也可以 )作為其運算元，並回傳單一數值。最常見的算術運算元是 加法 (+)，減法 (-)， 乘法 ()，及除法 (/)。 **賦值運算子 (Assignment Operators)**：將基於其右方的運算元的值賦予其左方的運算元。 利用 ||= 給預設值 123var a;a ||= 10;console.log('預設值是:', a); **比較運算子 (Comparison Operators)**：會比較運算元並基於比較的結果回傳邏輯值。 運算元可以是數字，字串，邏輯，或物件的值。當兩個運算元不具有相同型態， JavaScript 會嘗試將它們轉換成相同型態。通常是將運算元以數學形式對待。 **邏輯運算子 (Logical Operator)**：使用於布林值時，會回傳布林型態的值。 然而 &amp;&amp; 和 || 運算子實際上是回傳兩指定運算元之一，因此用於非布林型態值時，它可能會回傳一個非布林型態的值。 &amp;&amp; (AND) : 假如運算式1可以被轉換成 false 的話，回傳運算式1; 否則回傳運算式2。 只有在兩個運算元都是true 時才會回傳 true，否則回傳 false || (OR) : 假如運算式1可以被轉換成 true 的話，回傳運算式1; 否則回傳運算式2。 || 在兩個運算元有任一個是 true 時就會回傳 true，否則回傳 false ! (NOT) : 假如單一個運算元能被轉換成 true 時，回傳 false ， 不然回傳 true 三元運算子 Conditional (ternary) operator condition ? exprIfTrue : exprIfFalse condition : 用來作為條件的表達式 exprIfTrue : 如果 condition 的值是 true ， exprIfTrue 會被執行 exprIfFalse : 如果 condition 的值是 false ， exprIfFalse 會被執行 123var age = 26;var beverage = (age &gt;= 21) ? &quot;Beer&quot; : &quot;Juice&quot;;console.log(beverage); // &quot;Beer&quot; 控制流程if 判斷式語法 12345if (條件式) { 陳述式1} else { 陳述式2} 當條件成立(為 true )的時候會執行 if 陳述式裡的程式，而不成立時則執行另外一個陳述式。 以下轉換成布林值時為 false false undefined null 0 NaN “” ( 完全沒內容的空字串，只有一個空格也是真值) 使用 if…else 1234567let numA = 5;let numB = 6;if (numA === numB) { console.log('A等於B'); //不成立 不印} else { console.log('A不等於B'); //印出 A不等於B} 使用 else if 123456789let numA = 5;let numB = 6;if (numA === numB) { console.log('A等於B'); //不成立 不印} else if (numA &gt; numB) { console.log('A大於B'); //不成立 不印} else { console.log('A小於B'); //印出 A小於B switch語法 12345678910111213141516171819switch (表達式) { case value1: //當表達式的值符合 value1 //要執行的陳述句 break; case value2: //當表達式的值符合 value2 //要執行的陳述句 break; ... case valueN: //當表達式的值符合 valueN //要執行的陳述句 break; default: //當表達式的值都不符合上述條件 //要執行的陳述句 break;} 範例： 1234567891011121314151617181920212223var expr = 'Cherries';switch (expr) { case 'Oranges': console.log('Oranges are $0.59 a pound.'); break; case 'Apples': console.log('Apples are $0.32 a pound.'); break; case 'Bananas': console.log('Bananas are $0.48 a pound.'); break; case 'Cherries': console.log('Cherries are $3.00 a pound.'); break; case 'Mangoes': case 'Papayas': console.log('Mangoes and papayas are $2.79 a pound.'); break; default: console.log('Sorry, we are out of ' + expr + '.');}console.log(&quot;Is there anything else you'd like?&quot;); 忘記 break 時會發生什麼事 當 JavaScript 執行到 break 時，會跳出整個 switch 區塊，繼續往下執行。而如果沒有 break 則程式會從符合的 case 區塊開始，一路往下執行到遇到 break 為止。 範例： 1234567891011121314151617var foo = 0;switch (foo) { case -1: console.log('negative 1'); break; case 0: // foo is 0 so criteria met here so this block will run console.log(0); // NOTE: the forgotten break would have been here case 1: // no break statement in 'case 0:' so this case will run as well console.log(1); break; // it encounters this break so will not continue into 'case 2:' case 2: console.log(2); break; default: console.log('default');} for 迴圈語法 123for ([初始表達式]; [條件式]; [遞增表達式]) { 陳述句} 範例：從 1 數到 10 123for (var i = 1; i &lt;=10; i++) { console.log(i);} while 迴圈語法 123while (條件式) { 陳述句} 用 while 改寫 for 迴圈的範例 123456var i = 1;while ( i &lt;= 10 ){ console.log( i ); i++;} do while 迴圈先執行一次，再判斷要不要繼續執行 語法 1234do { 陳述句}while (條件式) 範例： 123456var i = 1;do { console.log( i ); i++;}while ( i &lt;= 10 ) break 與 continuebreak 會直接跳離迴圈 範例：從 1 數到 10，數到 4 就不想數了 12345for (var i = 1; i &lt;=10; i++) { console.log(i); if(i === 4) break;} continue 會跳過一次，然後繼續下一次迴圈 範例：從 1 數到 10，跳過 4 不數 12345for (var i = 1; i &lt;=10; i++) { if(i === 4) continue; console.log(i);} 函式 (Function) Don’t Repeat Yourself, DRY 函式是將一段或多段程式指令包裝起來重複使用，也方便維護。 Function 是 JavaScript 的一級物件(first class object)，可以當作別的函數的參數或作為一個變數的值。 定義函式的方式語法 123function 名稱 (參數) { // 要執行的功能} 一個函式的定義是由一系列的函式關鍵詞組成，分別為: 函式的名稱 包在()中的函式參數列表，參數與參數之間用逗號隔開 包在{}中用於定義函式功能的區塊 函式宣告 (Function Declaration)123function square (number) { return number * number; }; 函式表達式 (Function Expressions)將一個函式透過 = 指定給某個變數 123var squre = function (number) { return number * number;}; new Function 關鍵字建立函式作用域 (Scope)在 ES6 以前，只有函式能建立範疇，而在 ES6 之後，可用大括號 { ... } 定義區塊範疇，讓 const 和 let 宣告以區塊為範疇的變數。 範例：區域變數 12345678910111213141516function exampleFunction() { var x = &quot;declared inside function&quot;; // x 只能在 exampleFunction 函数中使用 console.log(&quot;Inside function&quot;); console.log(x);}exampleFunction();console.log(x); // 找不到 x 變數/*執行結果&quot;Inside function&quot;&quot;declared inside function&quot;x is not defined */ 範例：全域變數 12345678910111213141516171819var x = &quot;declared outside function&quot;;exampleFunction();function exampleFunction() { console.log(&quot;Inside function&quot;); console.log(x); // 內部找不到 x 會往外找}console.log(&quot;Outside function&quot;);console.log(x);/*執行結果&quot;Inside function&quot;&quot;declared inside function&quot;&quot;Outside function&quot;&quot;declared outside function&quot;*/ 提升 (Hoisting)變數和函式的宣告會在編譯階段就被先建立一個記憶體空間，等到實際執行時再將值放入記憶體空間內。 ES6 透過 let 宣告的變數不會有變數提升的效果。 範例：變數的提升 1234567891011console.log(x); // undefinedvar x = 10; console.log(x); // 10/* 實際運行順序var x;console.log(x);x = 10;console.log(x);*/ 範例：函式的提升 12345catName(&quot;Chloe&quot;); // &quot;My cat's name is Chloe&quot;function catName(name) { console.log(&quot;My cat's name is &quot; + name);} 回呼函式 (Callback Function)把函式當作另一個函式的參數，透過另一個函式來呼叫它 範例: 12345678910function greeting(name) { alert('Hello ' + name);}function processUserInput(callback) { var name = prompt('輸入你的名字：'); callback(name);}processUserInput(greeting); IIFE 函式 (Immediately Invoked Function Expression)用 function expression 的方式建立函式後並立即執行它 範例: 123var sayHi = function(name) { console.log('Hi, ' + name);}('Nick') 不用建立變數的寫法: 123(function(name) { console.log('Hi, ' + name);})('Nick') 物件 (Object)一個物件可以是零至多種屬性的集合，而屬性是鍵 (key) 與值 (value) 之間的關聯。一個屬性可以是基本型別、物件或是函式。 123456789var person = { name : ['Bob', 'Smith'], age : 32, gender : 'male', interests : ['music', 'skiing'], greeting: function() { alert('Hi! I\\'m ' + this.name[0] + '.'); }}; 物件的建立 透過 new 關鍵字建立，再一一新增其屬性 123456789var person = new Object();person.name = 'Bob';person.age = 32;person.gender = 'male';person.interests = ['music', 'skiing'];person.greeting = function() { alert('Hi! I\\'m ' + this.name[0] + '.');} 使用大括號 { } 建立 使用大括號 { } 建立，並在建立的同時直接指定屬性至物件內，這種建立物件的方式稱為物件實字 (Object Literal) 123456789var person = { name : 'Bob', age : 32, gender : 'male', interests : ['music', 'skiing'], greeting: function() { alert('Hi! I\\'m ' + this.name[0] + '.'); }}; 物件屬性的存取 透過 . 進行存取 123456789101112var person = { name : 'Bob', age : 32, gender : 'male', interests : ['music', 'skiing'], greeting: function() { alert('Hi! I\\'m ' + this.name[0] + '.'); }};person.name; // 'Bob'person.age; // 32 透過 中括號 [ ] 進行存取 123456789101112var person = { name : 'Bob', age : 32, gender : 'male', interests : ['music', 'skiing'], greeting: function() { alert('Hi! I\\'m ' + this.name[0] + '.'); }};person[&quot;name&quot;]; // 'Bob'person[&quot;age&quot;]; // 32 屬性刪除透過 delete 關鍵字來刪除 12345678910111213var person = { name : 'Bob', age : 32, gender : 'male', interests : ['music', 'skiing'], greeting: function() { alert('Hi! I\\'m ' + this.name[0] + '.'); }};delete person.name;person.name; // undefined 陣列 (Array)陣列是一種有順序的複合式的資料結構，陣列中可以存放任何值，數字、字串、其他陣列、函式等 陣列的建立語法 1var arrayName = [item1, item2, ...]; 範例： 1var fruits = ['Apple', 'Banana']; 陣列的操作取得陣列的長度123var fruits = ['Apple', 'Banana'];console.log(fruits.length); // 2 取得元素的索引123var fruits = ['Apple', 'Banana'];console.log(fruits.indexOf('Apple')); // 0 讀取陣列中的元素12345var fruits = ['Apple', 'Banana'];var first = fruits[0]; // Applevar last = fruits[fruits.length - 1]; // Banana 更改陣列中的值123456var fruits = ['Apple', 'Banana'];fruits[0] = 'Orange';fruits[1] = 123;console.log(fruits); // [&quot;Orange&quot;, 123] 新增元素 用 push() 新增元素到陣列最後面12345var fruits = ['Apple', 'Banana'];fruits.push('Orange');console.log(fruits); // [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;] 用 unshift() 新增元素到陣列最前面 12345var fruits = ['Apple', 'Banana'];fruits.unshift('Orange');console.log(fruits); // [&quot;Orange&quot;, &quot;Apple&quot;, &quot;Banana&quot;] 刪除元素 用 pop() 移除陣列中最後一個元素pop() 除了移除元素，還會返回移除的元素值 12345var fruits = ['Apple', 'Banana'];var last = fruits.pop(); // Banana console.log(fruits); // [&quot;Apple&quot;] 用 shift() 移除陣列中第一個元素 12345var fruits = ['Apple', 'Banana'];var first = fruits.shift(); // Appleconsole.log(fruits); // [&quot;Banana&quot;] 擷取陣列中的元素語法 1ary.slice(begin, end) begin 表示開始擷取的索引位置 end 表示結束擷取的索引位置，擷取的範圍不包含 end 元素，如果 end 是負數，表示從陣列後面算起，例如 -1 表示最後一個元素的位置 範例： 123456789var fruits = [ 'Apple', 'Banana', 'Orange', 'Lemon', 'Mango'];var foo1 = fruits.slice(1, 3);console.log(foo1); // [&quot;Banana&quot;, &quot;Orange&quot;]var foo2 = fruits.slice(2, -1);console.log(foo2); // [&quot;Orange&quot;, &quot;Lemon&quot;] 參考資料 MDN JavaScript","link":"/2020/12/13/JavaScript-Basic/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"AJAX","slug":"AJAX","link":"/tags/AJAX/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Command Line","slug":"Command-Line","link":"/tags/Command-Line/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"HEXO BLOG","slug":"HEXO-BLOG","link":"/tags/HEXO-BLOG/"},{"name":"Bootstrap","slug":"Bootstrap","link":"/tags/Bootstrap/"},{"name":"AXAJ","slug":"AXAJ","link":"/tags/AXAJ/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"WSL","slug":"WSL","link":"/tags/WSL/"}],"categories":[]}